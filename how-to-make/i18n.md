# Как настроить локализацию?

Если под локализацией вы подразумеваете то же, что и мы — перевод сайта на другие языки, — тогда вы, как и мы, 
заблуждаетесь. 

Читаем Википедию.

**Локализация** — процесс адаптации веб-приложения к культуре какой-либо страны. 

**Интернационализация** — технологические приёмы разработки, упрощающие адаптацию продукта к языковым и культурным 
особенностям регионов, отличных от того, в котором разрабатывался продукт.

Важное отличие одного от другого можно сформулировать совсем коротко. Интернационализация — это адаптация продукта 
для использования _в разных странах_, в то время как локализация — это добавление специальных функций для 
использования _в какой-то определённой стране_.

Мы, разработчики сайтов, говорим "локализация", но обычно подразумеваем только лишь перевод сайта на разные языки. 
А так как этот документ именно о переводах, придётся его переозаглавить.
 
# Как настроить интернационализацию?

В английском языке для слова `internationalization` принято сокращение `i18n`. При этом число `18` означает количество 
пропущенных между `i` и `n` букв. Для Локализации `Localization` применяют сокращение `L10n`. Заглавная буква `L` 
используется чтобы не путать с `i` в `L10n`, число `10` — количество букв между `L` и `n`.

Неудивительно, что инструменты, которые так или иначе связаны с интернационализацией, называются с использованием 
сокращения `i18n`. В `BEViS` мы не стали ломать привычки. Наши инструменты для интернационализации называются так же.

Освоить их проще простого, если вы вместе с нами освоили задания из последнего занятия про [yblock](yblock.md).

Теперь у вас есть страница `/pages/test-page/test-page.page.js`, на которой к этому моменту задекларирован один 
единственный блок `form`. Добавим в блок новую опцию `titleText`, в которую передадим произвольный текст. Его-то мы и
 будем переводить на разные языки. 
 
 У вас должна получиться такая структура:

```javascript
module.exports = function (pages) {
    pages.declare('test-page', function (params) {
        var options = params.options;
        return {
            block: 'page',
            title: 'test page',
            styles: [
                {url: options.assetsPath + '.css'}
            ],
            scripts: [
                {url: options.assetsPath + '.' + params.lang + '.js'}
            ],
            body: [
                {
                    block: 'form',
                    titleText: 'Лучший кофе на дороге'  // <---------- Новая опция
                }
            ]
        };
    });
}
```

Допишем шаблон для формы. Будем принимать опцию `titleText` и создавать элемент блока `head`, который в `DOM`-дереве 
будет представлен заголовком `h1` с переданным текстом.

Было:
```javascript
module.exports = function (bt) {

    bt.match('form', function (ctx) {
        ctx.enableAutoInit();

        ctx.setTag('span');

        ctx.setContent('Содержимое блока');
    });

};
```

Стало:
```javascript
module.exports = function (bt) {

    bt.match('form', function (ctx) {
        ctx.enableAutoInit();

        ctx.setTag('span');

        var title = ctx.getParam('titleText');
        ctx.setContent(
            {
                elem: 'head',
                text: title
            }
        );
    });

    bt.match('form__head', function (ctx) {
        ctx.setTag('h1');

        var headText = ctx.getParam('text');
        ctx.setContent(headText);
    });

};
```

_Я нарочно дал совершенно разные имена опциям шаблона и локальным переменным, чтобы вам было легче проследить, 
как текст "Лучший кофе на дороге" передаётся от опции `ctx.getParam('titleText')` до установки контента в 
`ctx.setContent(headText);`. Проследите-проследите :) Освежите свои знания про генерацию `HTML` из `BT`-шаблонов._ 

Обновим страницу `localhost:8080/test` в браузере и увидим огромный заголовок про кофе. Я вижу, а вы?

Очевидно, что в опцию `titleText` передавать готовую строку на русском языке нельзя. Надо передавать какой-то ключ, 
по которому нужно _где-то_ получать русский текст для интерфейса на русском языке, английский текст для 
интерфейса на английском языке, украинский для украинского, турецкий для турецкого и т.д.

Слово _где-то_ я выделил курсивом, чтобы сразу о нём поговорить. Невозможно локализировать сайт, не имея некоего 
хранилища переведённых текстов. В `BEViS` такое хранилище мы организовали в виде файлов. Создадим его вместе с вами.

Создайте папку `blocks/i18n/_keyset`.

Это будет специальное место, где будут храниться переводы всех блоков. Почему внутри папки `blocks/i18n` мы создали 
подпапку `_keyset` — об этом не задумывайтесь. Это всё обсудим позже. Сейчас переходим к самому интересному.  

Мы готовим переводы для блока `Form`, поэтому создадим набор ключей для этого блока. Набор ключей будем называть 
кисетом (если на ваш взгляд слово "кейсет" звучит лучше, называйте так). Давайте создадим кисет для формы.
   
Создаём папку `blocks/i18n/_keyset/i18n_keyset_form.i18n`. Опять же, пока не задумываемся, почему такое странное 
название у директории. А внутри неё создаём единственный (пока) языковой-файл `ru .js` и пишем в него единственный  
(пока) ключ с переводом:

`blocks/i18n/_keyset/i18n_keyset_form.i18n/ru.js`:
```javascript
module.exports = {
    "form": {
        "title-text": "Лучший кофе на дороге"
    }
};
```

Остановимся на содержимом подробнее.

Языковой файл `ru.js` — это обычный `Node.js`-модуль, который экспортирует объект с единственным полем, который мы 
назвали `form`. Мы назвали его так, чтобы имя кисета перекликалось с именем блока `Form`, который мы видим на 
web-странице. Когда имена перекликаются, так легче.

В этом файле сейчас мы описали только один ключ `title-text` и его значением сделали тот самый текст про кофе. Для 
наглядности добавим ещё один ключ. Сейчас он нам не нужен, а позже пригодится.
 
`blocks/i18n/_keyset/i18n_keyset_form.i18n/ru.js`:
```javascript
module.exports = {
    "form": {
        "title-text": "Лучший кофе на дороге",
        "hint-content": "Иллюзионист иллюстрирует иллюзорно"
    }
};
```

Хранилище готово. Конечно, оно готово (пока!) только для русского языка. Сразу приготовим тексты для английского 
языка. Создадим в той же папке файл с именем `en.js`.
 
`blocks/i18n/_keyset/i18n_keyset_form.i18n/en.js`:
```javascript
module.exports = {
    "form": {
        "title-text": "The best coffee on the road",
        "hint-content": "Illusionist illustrates illusorily"
    }
};
```
 
А теперь давайте сделаем так, чтобы приложение ходило за текстом про кофе именно в это хранилище.

Первое, что мы делаем всегда после создания нового блока, указываем зависимость — сообщаем, что такой-то 
блок будет использоваться на такой-то странице. 
  
Редактируем `pages/test-page/test-page.deps.yaml`, добавляемость зависимость к блоку (`i18n`) и указываем, какой именно
 кисет используется на этой странице (`form`): 
```
- page
- block: block
  elem: auto-init
- input
- super-input
- form
- block: i18n
  keyset: form
```

Всё. Теперь в декларации страницы убираем русский текст и просим вместо него ключ из хранилища:

```javascript
module.exports = function (pages) {
    pages.declare('test-page', function (params) {
        var options = params.options;
        return {
            block: 'page',
            title: 'test page',
            styles: [
                {url: options.assetsPath + '.css'}
            ],
            scripts: [
                {url: options.assetsPath + '.' + params.lang + '.js'}
            ],
            body: [
                {
                    block: 'form',
                    titleText: pages.i18n('form', 'title-text') // <------ Здесь зовём i18n-ключ
                }
            ]
        };
    });
};
```
 
Обновляем страницу в браузере, видим текст про кофе. Как понять, вдруг это кеш, а у нас ничего не получилось? Можно 
изменить текст в кисете и проверить. Редактируем?

`blocks/i18n/_keyset/i18n_keyset_form.i18n/ru.js`:
```javascript
module.exports = {
    "form": {
        "title-text": "Лучший кофе на дороге — отхлебнёшь, протянешь ноги! (с)", // <----- Изменили значение
        "hint-content": "Иллюзионист иллюстрирует иллюзорно"
    }
};
```

Обновляем в браузере. Есть новый текст! Оглушительный успех ;)

Мы позвали перевод, находясь внутри декларации страницы. У объекта `pages` есть метод `i18n`, который умеет принимать 
два параметра — имя кисета и имя ключа:
```javascript
pages.i18n('form', 'title-text')
```

Этот метод ходит в хранилище переводов, находит там нужный кисет (`form`), а в нём нужный ключ (`title-text`) и 
возвращает значение ключа (`Лучший кофе на ...`) 

Этот метод доступен нам не только в декларации страницы. Он так же доступен нам в `bt`-шаблонах любого блока.

Откроем `blocks/form/form.bt.js` и добавим новый элемент `hint`:
```javascript
module.exports = function (bt) {

    bt.match('form', function (ctx) {
        ctx.enableAutoInit();

        ctx.setTag('span');

        var title = ctx.getParam('titleText');
        ctx.setContent([
            {
                elem: 'head',
                text: title
            },
            {
                elem: 'hint',                                     // <----- Создали новый элемент
                textHint: bt.lib.i18n('form', 'hint-content')     // <----- Позвали ключ для него
            }
        ]);
    });

    // Шаблон для элемента hint
    bt.match('form__hint', function (ctx) { 
        ctx.setContent(ctx.getParam('textHint'));
    });

    bt.match('form__head', function (ctx) {
        ctx.setTag('h1');

        var headText = ctx.getParam('text');
        ctx.setContent(headText);
    });

};
```

В шаблоне формы мы сгенерили новый элемент `hint` и в его опцию `textHint` передали значение ключа `hint-content`. 
Когда обновим браузер, увидим под заголовком текст про иллюзиониста.

Мы рассматривали способы, как звать ключи, находясь в декларации страницы или в `bt`-шаблонах блока.

Декларация страницы работает на сервере, создаёт статический `HTML`, который летит пользователю в браузер.
`BT`-шаблоны умеют работать как на сервере, так и в браузере.

А как пользоваться `i18n` в клиентском `javascript`?                                             

```javascript
modules.define(
    'form',
    [
        'inherit',
        'block',
        'input',
        'super-input',
        'y-i18n'        // <---------- Позвали клиентский модуль y-i18n
    ],
    function (
        provide,
        inherit,
        YBlock,
        Input,
        SuperInput,
        i18n            // <---------- Приняли его в качестве аргумента i18n
    ) {
        var form = inherit(YBlock, {
            __constructor: function () {
                this.__base.apply(this, arguments);

                var formDomNode = this.getDomNode();

                // Создаём инпут
                this._greetingInput = new Input({
                    value: 'Привет, Бивис',
                    name: 'loginField',
                    placeholder: 'Инпут на сайте',

                    parentNode: formDomNode
                });
                this._greetingInput.on('input-submitted', this._onInputSubmitted, this);

                // Создаём инпут для пароля
                this._passwordInput = new SuperInput({
                    name: 'passwordField',
                    type: 'password',
                    placeholder: i18n('form', 'hint-content'), // <---------- Позвали любой ключ

                    parentNode: formDomNode
                });
                this._passwordInput.on('input-submitted', this._onInputSubmitted, this);
            },

            /**
             * Реагирует на нажатие клавиши Enter в `Input`
             * @param {YEventEmitter} e
             */
            _onInputSubmitted: function (e) {
                console.log('Форма поймала событие на Input = ', e);
            }
        }, {
            getBlockName: function () {
                return 'form';
            }
        });

        provide(form);
});
```
Я минимально изменил класс `Form`, пометив все изменения комментариями. В прейсхолдер инпута для пароля я позвал  
строку про иллюзиониста. Обновите страницу в браузере. Успех?

Обратите внимание на важный момент.

В проекте есть две сущности с почти одинаковыми названиями.

1. В движке проекта _уже есть_ специальный модуль с именем `y-i18n`, который вы можете звать в своих клиенстких  
модулях, как в примере выше. Этот модуль создавать не нужно, он просто есть по умолчанию, находится где-то в файлах 
`BEViS`-движка. Он умеет умеет ходить в ваше хранилище переводов и забирать оттуда строки на разных языках. 
2. И есть _ваше хранилище_ переводов, которое находится по адресу `blocks/i18n`. Хранилище представлено неким блоком,
 имеющим имя `i18n`, и его элементом `_keyset`. Мы специально реализовали хранилище в виде так называемого `блока`, 
 чтобы им удобно было пользоваться. Напомню, чтобы им пользоваться, нужно только в зависимостях страницы указать этот
  блок и имя нужного кисета, как мы делали это выше в файле `pages/test/test-page.deps.yaml`:
```
- page
- block: block
  elem: auto-init
- input
- super-input
- form
- block: i18n    # <----- Позвали на страницу хранилище переводов 
  keyset: form   # <----- Указали, каким кисетом будем пользоваться.
```

Можно указывать столько кисетов, сколько хочется, если в `yaml`-файле перечислить их в виде массива:
```
- block: i18n     
  keyset: [form, any-other] # <----- Позвали кисеты form и any-other
```

Зависимости можно указывать не только в страничных файлах, а в блоках. Например, мы знаем что модуль `Form` 
использует внутри себя переводы. Тогда кисеты можно подтягивать не в страничном `pages/test/test-page.deps.yaml`, а в
 блочном `blocks/form/form.deps.yaml`. Этого файла ещё нет. Создадим его и напишем в нём:
```
- block: i18n     
  keyset: [form, any-other]
```

А в страничном `pages/test/test-page.deps.yaml` удалим эту зависимость и обновим страницу в браузере. Ничего не 
сломалось, иллюзионист что-то там иллюстрирует в поле для пароля. Ну, отлично. Получается, что любой блок в своём 
файле зависимостей может указать, от каких других блоков именно он зависит. Если зависимости указывать таким образом,
 гарантирован порядок — на страницу придут только те модули, которые нужно конкретным блокам на текущей странице. 
  
Обратили внимание, что мы указали зависимость к кисету `any-other`, а его нет на файловой системе? Ну и ничего не 
сломалось при обновлении страницы. А что случится, если мы в клиентском модуле попробуем получить ключ из этого 
кисета? Пробуем? Давайте отредактируем в модуле `Form` вызов конструктора инпута для пароля:
 
```javascript
// Создаём инпут для пароля
this._passwordInput = new SuperInput({
    name: 'passwordField',
    type: 'password',
    placeholder: i18n('any-other', 'my-key'), // <---- Позвали несуществующий ключ 'my-key' из 
                                              //       несуществующего кисета 'any-other'

    parentNode: formDomNode
});
```

После рефреша страницы в консоли видим ошибку:
```
Uncaught Error: form init error: Keyset "any-other" was not found.
```

Отлично, приложение помогает понять, что мы что-то забыли. Давайте создадим этот кисет и будем заканчивать.

Кстати, я не сказал, в приложении есть скрипт для создания кисетов из терминала:
```
make keyset
# Введите имя keyset
```

Этот скрипт создаёт в хранилище нужную папку для кисета и два файла с переводами - `ru.js` и `en.js`. В каждом создаёт 
 один фейковый ключ, который назван незатейливо `my-key`. В английском файле значение ключа установлено в `my value`, 
 а в русском в `моё значение`. Я же говорю, кисет незатейливый :)
 
После рефреша в поле пароля видим плейсхолдер "моё значение". 

Всё, теперь вы знаете всё, чтобы сделать сайт интернационализированным. Осталось самое главное :)

## Как переключать интерфейс на другой язык?

Конечно, мы наделали кучу файлов с переводами, умеем из них получать строки, умеет это делать в страничном `btjson`, 
в `bt`-шаблонах и даже в клиентских `javascript`-модулях. А как переключить приложение на другой язык? 
 
Откроем `pages/test/test-page.page.js`:
```javascript
 module.exports = function (pages) {
     pages.declare('test-page', function (params) {
         var options = params.options;
         return {
             block: 'page',
             title: 'test page',
             styles: [
                 {url: options.assetsPath + '.css'}
             ],
             scripts: [
                 // {url: options.assetsPath + '.' + params.lang + '.js'}  
                 {url: options.assetsPath + '.en.js'}  
             ],
             body: [
                 {
                     block: 'form',
                     titleText: pages.i18n('form', 'title-text')
                 }
             ]
         };
     });
 };
```






   
 


 




 



