# Модульная система YMaps Modules

Что такое Модульная система? Зачем и для кого? Как этим пользоваться?

На эти вопросы я давно хотел получить ответы, но стеснялся их задать. Если вы такой же робкий, этот документ для вас :)

Что это?
--------
Вы web-разработчик, пишете сайты; на страницах верстаете формы с контролами,
различные компоненты, большие и маленькие; для большинства из них
пишете клиентский `js`-код. Вот и продолжайте это делать. Пока у вас нет своего клиентского `js`-кода,
модульная система вам не нужна. Никому не нужен пустой фантик без конфеты внутри.

Модуль - это фантик, в который вы заворачиваете конфету. На фантике написано имя конфеты и больше ничего. Оберните 
код пяти своих контролов каждый в свой отдельный фантик, у вас получится 5 модулей — система из пяти **ваших** 
модулей. Конфеты ссыпают в корзинку для сладостей, откуда конфеты удобно таскать детям. Модульная система и есть 
такая корзинка.

Зачем это и для кого?
--------------------
Как вы связываете `js`-компоненты между собой? Например, вы объявляете на странице блок с формой авторизации,
пишете для неё клиентский `js`-код, в котором описываете поведение формы: если нажали на кнопку сабмита — отправь
авторизационные данные аяксом, а не через стандартный `form.submit()`.

И предположим, в вашем проекте уже есть специальный компонент "кнопка", в котором реализовано всё поведение кнопки,
например, "если меня нажали, выкинь вверх некое событие, чтобы форма могла это событие услышать и отреагировать нужным 
образом".

То есть, ваша "форма" должна уметь найти кнопку и слушать на ней событие клика.

Вопрос: а как вы определяете, что кнопка **уже готова** взаимодействовать с вашей формой? Наверное, в `js`-файле вы 
сначала описываете функциональность для кнопки, а ниже - для формы? А если js-код кнопки и формы лежат в разных 
файлах? Тогда вы так настраиваете сборку финального `js`-файла, чтобы всё равно код формы оказался описан ниже 
кода кнопки?

Модульная система избавляет нас от этих трудностей. Она избавляет нас от головной боли отслеживать зависимости между
компонентами, поддерживать руками эти зависимости в актуальном состоянии. 

Если вы оформляете форму в виде `ymaps-модуля`, вы просто декларируете зависимость от кнопки, и знаете,
что код формы будет активирован _только тогда_, когда активирован код кнопки. Вам не нужно самому отслеживать 
готовность ваших компонентов взаимодействовать друг с другом. Это делает за вас модульная система.


Как этим пользоваться?
---------------------
Это болванка `ymaps-модуля`:

````javascript
modules.define(
    'A',
    ['B', 'C'],
    function(provide, b, c) {
        var a = {};

        provide(a);
    }
);
````

В этом примере ваш собственный код  - единственная строка:
````javascript
var a = {};
````

В реальности, конечно, там будет написано куда больше всего. Но для знакомства с модульной системой этого достаточно.

Всё остальное кроме этой строки и есть модуль. Модуль - это своего рода обёртка, фантик — несколько специальных 
инструкций, которые и делают из вашего кода модуль. Внутрь фантика вы складываете нужные ингредиенты (зависимости от 
 других модулей), перемешиваете, как вам хочется (пишете код своего компонента), фантик скручиваете и втыкаете
в бок зубочистку-флажок с именем модуля. Вы сделали модуль `А`.

Давайте посмотрим на конфету внимательно.

Так объявляется модуль. Позовите метод `define()`
````javascript
modules.define(
);
````

Скажите модулю: "Тебя зовут `А`"
````javascript
modules.define(
    'A'
);
````

Потом добавьте: "Вообще-то ты зависишь от двух модулей, их зовут`В` и `С`"
````javascript
modules.define(
    'A',
    ['B', 'C'],
);
````

Опишите код модуля в анонимной функции. В него параметрами `b` и `c` придёт код модулей `B` и `С`, и вы сможете  
использовать их внутри модуля.
````javascript
modules.define(
    'A',
    ['B', 'C'],
    function(provide, b, c) {

    }
);
````

Чтобы другие модули могли использовать этот модуль, пусть ваш модуль громко произнесёт вслух:
"Модуль `А` - это я!". Это делается вызовом функции `provide(а)`, в которую аргументом передаётся ссылка на ваш класс
 или объект, то есть на сам программный код вашего модуля.
````javascript
modules.define(
    'A',
    ['B', 'C'],
    function(provide, b, c) {
        var a = {};

        provide(a);
    }
);
````

И, наконец, напишите свой компонент. Пусть это будет что-нибудь хорошее ;)
````javascript
modules.define(
    'A',
    ['B', 'C'],
    function(provide, b, c) {
        var a = 'Yandex is a good company';

        provide(a);
    }
);
````

Всё. Сложности закончились :)

А вот так, к примеру, может выглядеть код модуля, отвечающий за форму логина. Создадим фантик,
позовём в него кнопку и что-нибудь запрограммируем внутри:
````javascript
modules.define(
    'form',
    ['button'],
    function(provide, button) {
        var form = getElementById('my-form');
        form.on('submit', onSubmited);

        function onSubmited() {
            if ($(button).css('disabled')) {
                return false;
            }
            form.submit();
        }

        provide(form);
    }
);
````

Это выдуманный пример, скорее всего он нерабочий, но для иллюстрации годится. В теле анонимной функции мы программируем 
поведение формы в зависимости от того, активна или неактивна кнопка. А после этого методом `provide(form)` 
выбрасываем вверх флаг: "Форма — это я". Теперь и этот модуль может быть вызван другими модулями. Метод `provide` - 
это выкинутая вверх рука и всемирно известное: "Свободная касса!"

Возвращаясь к аналогии с конфетой, фантик — это метод `define()` с анонимной функцией внутри. В фантик воткнута  
зубочистка, за которую конфетку удобно взять — это метод `provide()`. Модуль независим и работоспособен, потому что 
он  будет запущен только после того, как все зависимости будут предоставлены (правильные программисты используют  
термины "разрезолвлены" или "разрешены") внутрь модуля.

Осталось сказать, что зависимости резолвятся асинхронно, дерево зависимостей строится в рантайме,
модули можно переопределять и доопределять. А теперь возвращаю вас к главной странице инструмента: 
https://github.com/ymaps/modules

Пользуйтесь на здоровье, автор инструмента желает вам успехов и не против выпить с вами вкусного коньяку ;)

PS. Кстати, дерево зависимостей, построенное модульной системой, можно использовать в любом файловом сборщике,
потому что имя модуля легко мапится на имя файла,в котором этот модуль хранится. И тогда
вы ещё и собирать файлы руками не будете, всё будут делать роботы ;)


Багрепорты, сложные вопросы и благодарности присылайте на dfilatov@yandex-team.ru :)