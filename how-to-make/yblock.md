# YBlock

Мы с вами проделали уже большой путь: 
* [создали новую страницу](new-page.md),
* [создали новый блок и написали простые bt-шаблоны](new-block.md),
* [написали к блоку стили и расширили bt-шаблоны](css.md).

У нас есть страница `/pages/test-page/test-page.page.js`, а в ней единственный блок `input`:

```javascript
module.exports = function (pages) {
    pages.declare('test-page', function (params) {
        var options = params.options;
        return {
            block: 'page',
            title: 'test page',
            styles: [
                {url: options.assetsPath + '.css'}
            ],
            scripts: [
                {url: options.assetsPath + '.' + params.lang + '.js'}
            ],
            body: [
                {
                    block: 'input',
                    view: 'large',
                    value: 'Привет, Бивис',
                    name: 'loginField',
                    placeholder: 'на сайте'
                }
            ]
        };
    });
}
```

Если проект запустить, то по адресу `http://localhost:8080/test` мы увидим страницу с серым фоном и текстовым полем,
в котором уже введено значение "Привет, Бивис".

Если в браузере заглянуть в `HTML`-код блока, увидим следующую структуру:

```html
<div class="input_large _init" data-block="input">
    <input class="input_large__control" value="Привет, Бивис" name="loginField" placeholder="Инпут на сайте">
    <div class="input_large__clear"></div>
</div>
```

Созданием этого `HTML`-кода занимаются `bt`-шаблоны, которые мы с вами написали в файле `/blocks/input/input.bt.js`.
Стилизацией блока занимается целая система файлов `/blocks/input/input*.styl`.

Самое время запрограммировать поведение блока — cделать блок интерактивным, т.е. отзывчивым на действия пользователя.

Когда мы [создавали новый блок](new-block.md), мы сделали заготовку для клиентcкого программирования. Вот она:

`/blocks/input/input.js`

```javascript
modules.define(
    'input',
    ['inherit', 'block'],
    function (provide, inherit, YBlock) {
        var Input = inherit(YBlock, {
            __constructor: function () {
                this.__base.apply(this, arguments);

                console.log(this.getValue());
            },

            getValue: function() {
                return this.getDomNode().val();
            },


            setValue: function(value) {
                this.getDomNode().val(value);
            }
        }, {
            getBlockName: function () {
                return 'input';
            }
        });

        provide(Input);
});
```

Ничего не понятно — какая-то простыня методов и куча непонятных слов!

Обещаю, через 5 минут будете спокойно ориентироваться в этой "простыне", а через 15 уже сами будете осознанно писать 
 такое и даже круче. 

На что мы сейчас смотрим? Мы смотрим на заготовку, которая мало что умеет делать. Да и выглядит, если честно, странно: 
какой-то `module.define()`, какой-то `provide`. Что это?

## Модули
Мы пишем клиентский `javascript` в виде модулей. Если сказать по-простому, то мы пишем `javascript`-программу и 
помещаем её в специальный контейнер, который называем модулем.

Модульных систем много разных, Бивис использует [Ymaps Modules](modules.md), которые придумали и разработали
разработчики из Яндекс.Карт. Пройдите по ссылке, прочитайте.

В основе модулей лежит очень простая идея, и в документации к `Ymaps Modules` простым языком описывается,
зачем модульная система нужна и как её использовать.

Не стали читать? ;) Там чтения на пять минут. Мы всё таки настаиваем, вам понравится.
[Прочитайте](modules.md).

Прочитали? Тогда вы понимаете, что код внутри анонимной функции - это и есть код,
который программирует поведение вашего `input`. Можно было бы программировать его по старинке,
навешивая события на `DOM`-элементы самим или через jQuery-хелперы. Но мы предпочитаем работать с блоками через
абстракции, чтобы не зависеть от `HTML`-реализации блока.

Поэтому мы в зависимостях модуля `input` указали два других модуля — `inherit` и `block`.
Первый модуль возвращает функцию `inherit`, которая используется для создания классов и наследования (подробное
описание читайте на странице автора:
[https://github.com/dfilatov/node-inherit](https://github.com/dfilatov/node-inherit).

Второй модуль (`block`) - это `javascript`-класс, который реализует механизмы абстрагирования от `DOM`-узлов. Это 
базовый визуальный блок.

_Все блоки, которые вы создаёте в проекте и которые пользователь может 
увидеть на страницах вашего сайта (мы такие блоки называем визуальными), должны наследоваться от
модуля `block` с помощью модуля `inherit`._

Я употребил слово "наследоваться". Это слово звучит странно применительно к программе на `Javascript`.
Наверное, каждому веб-разработчику известно, что нативного механизма наследования в `Javascript` нет. Но есть
эмуляции, одна из них как раз и есть модуль [inherit](https://github.com/dfilatov/inherit). Документация к этому модулю
написана серьёзно, академически. Здесь же мы попытаемся быстро и по-простому объяснить смысл этого модуля.

Вот вся суть:
```javascript
var B = inherit(A, {});
```

Создаём класс `B`, который наследует методы из класса `A`, и доопределяет своими собственными методами. Эти
дополнительные методы описываются во втором аргументе функции `inherit`. В примере выше никаких методов внутри 
второго параметра не описано, поэтому класс `B` просто отнаследуется от класса `A`.

А уже в этом коде мы с вами создадим класс `Input`, как наследника от класса `YBlock`, и насытим его собственными 
методами `getValue` и `setValue`:

```javascript
var Input = inherit(YBlock, {
    __constructor: function () {
        this.__base.apply(this, arguments);

        console.log(this.getValue());
    },

    getValue: function() {
        return this.getDomNode().val();
    },


    setValue: function(value) {
        this.getDomNode().val(value);
    }
});
```

## Конструктор Класса
Метод `__constructor` - особый метод. Если другие методы мы вольны называть как нам нравится, то
именно этот метод должен называться так и никак иначе. Это конструктор класса.

В объектно-ориентированном программировании конструктор класса — это специальная функция, вызываемая при создании
объекта класса. Создадим объект нашего класса `Input`:

```javascript
var myInput = new Input();
```

Когда `javascript`-интерпретатор приступит к выполнению конструкции `new Input()`, он первым делом вызовет функцию
`__constructor`. Можно считать, что это точка входа в вашу программу, описанную в файле `/blocks/input/input.js`

Интерпетатор входит в метод `__constructor` и выполняет всё, что вы там написали.

А написано там пока немного.

Во-первых, инструкция `this.__base.apply(this, arguments);` - её можно не пытаться понять,
просто запомнить и писать в каждом конструкторе каждого вашего блока. 

_Вообще-то это способ из конструктора класса `Input` вызвать конструктор класса `YBlock`._
_То есть, вы описали класс `Input` как наследника от класса `YBlock`. А потом создали экземпляр `myInput`. В тот момент,
когда вы создали объект `myInput`, вызвался его `__constructor`, который вызвал точно такой же `__constructor` 
в `YBlock`._

Если строка `this.__base.apply(this, arguments);` выглядит пугающе, не обращайте внимания, эта строка неинтересная. 
Интересно другое.

С помощью модуля `inherit` мы пишем клиентский `javascript`-код в `ООП`-стиле. Не в виде спагетти-функций, которые друг
друга вызывают в хаотичном порядке, а в виде классов и порожденных ими объектов.

В конструкторе ровно это и происходит - мы вызываем собственный метод `getValue` и результат выводим в консоль браузера:

```javascript
__constructor: function () {
    this.__base.apply(this, arguments);

    console.log(this.getValue());
}
```

Ещё раз о важном. Работа любого модуля начинается с метода `__constructor`. Это точка входа в программу модуля. А уже
 из контруктора мы сами организуем работу модуля как хотим - слушаем события, реагируем на них, может быть, 
 инициализируем какие-то другие модули — что угодно.
 
Например, контрол `input` имеет элемент `clear`, по нажатию на который мы должны очистить поле ввода от введенного 
текста. Алгоритм задачи я бы для себя описал так:

1. Найти элемент, сохранить на него ссылку.
2. Забиндить событие клика на нём и повесить обработчик клика.
3. В обработчике стереть текст из текстового поля.
 
Измените метод `__constructor`, чтобы он выглядел как у меня: 
 
```javascript
__constructor: function () {
    this.__base.apply(this, arguments);

    // 1. Найти элемент, сохранить на него ссылку.
    var clear = this._findElement('clear');
    console.log(clear);
}
```

И тут мы знакомимся с методом `_findElement` — для нас первым методом блока `YBlock` (от которого мы отнаследовали
`Input`). 

## Поиск элемента с помощью `_findElement`

Первое, что бросается в глаза — знак нижнего подчеркивания перед именем. Почему `_findElement`, а не `findElement`?
Символ нижнего подчеркивания — это индикатор, что метод приватный... Как бы приватный :) "Как бы", потому что этот  
символ перед именем `javascript`-метода ни на что не влияет. Это в настоящих ООП языках такой метод не может быть  
вызван из другого компонента — сам язык программирования не позволит вам этого сделать технически. Но в `Javascript` 
 такой возможности нет, но очень хочется :)
 
 Хочется отделить публичные методы компонента (которые могут быть вызываны из других компонентов) от приватных 
 методов (которые доступны для вызова только изнутри). А раз технической возможности нет, но сильно хочется, то можно 
 договориться между разработчиками и соблюдать устную договорённость. Мы и договорились — если перед именем метода есть 
 символ нижнего подчеркивания, это метод приватный, относись к нему с почтением :)
   
Так как блок `Input` отнаследован от `YBlock`, то метод `_findElement` у инпута есть. Собственно ради этого метода и 
многих других мы от `YBlock` и хотим наследоваться. Увидеть все методы блока `YBlock` вы 
можете [по этой ссылке.](https://github.com/bevis-ui/bevis-stub/blob/master/core/block/block.js)

А сигнатуру метода `_findElement` мы посмотрим прямо здесь:

```javascript
/**
 * Возвращает первый элемент с указанным именем.
 *
 * @protected
 * @param {String} elementName Имя элемента.
 * @param {HTMLElement|jQuery} [parentElement] Элемент в котором необходимо произвести поиск. Если не указан,
 *                                             то используется результат `this.getDomNode()`.
 * @returns {jQuery|undefined}
 *
 * @example
 * var title = this._findElement('title');
 * title.text('Hello World');
 */
_findElement: function (elementName, parentElement) {
    return this._findAllElements(elementName, parentElement)[0];
}
```
Первый парамет метода - строковое имя элемента, который мы ищем. Обязательный параметр.

Второй параметр — необязательный, о чём нам в `JSDoc`-е говорит имя параметра, заключённое в квадратные скобки 
`[parentElement]` — родительский элемент, в котором необходимо произвести поиск. Обратите внимание, что в этот 
параметр нужно передавать не строковое имя элемента (как было в первом параметре), а именно сам элемент в виде 
`HTMLElement` или в виде `jQuery`, о чём нам сообщает тип параметра
 
```
@param {HTMLElement|jQuery} [parentElement]
```

Метод возвращает `jQuery`, если такой элемент найден, или `undefined`, если такого элемента не существует:
 
```
@returns {jQuery|undefined}
```

Так как этот метод отнаследован нами из `YBlock`, то и вызываем мы его так, словно это метод блока `Input` - через 
ключевое слово `this`. А если отодвинуться от монитора и посмотреть на строчку свежим взглядом, то можно прочитать её,
 как предложение на русском языке. 
```javascript
    var clear = this._findElement('clear');
    // У этого блока найди элемент 'clear' и сохрани его в локальной переменной. 
}
```
Понятно ведь, правда?


Ниже строки с вызовом `_findElement` мы добавили вывод в консоль и теперь посмотрим, что вернёт метод в нашей 
программе. Обновляем `http://localhost:8080/test` (или открываем, если закрыли) и видим в консоли браузера что-то  
подобное:

```javascript
{
    0: 'div.input_large__clear',
    context: 'div.input_large__clear',
    length: 1,
    __proto__: x[0]
}
``` 
Это `jQuery`-представление нашего элемента `clear`. Отлично, значит элемент нашли и сохранили в локальную переменную 
внутри метода `__constructor`.

## Навешивание и обработка событий
 
Двигаемся дальше, и будем слушать событие `click` на крестике:
 
```javascript
__constructor: function () {
    this.__base.apply(this, arguments);

    // 1. Найти элемент, сохранить на него ссылку.
    var clear = this._findElement('clear');
    
    // 2. Забиндить событие клика на нём и повесить обработчик клика.
    this._bindTo(clear, 'click', function () {
        console.log('Крестик нажат');
    });
}
```

Знакомимся со следующим методом — `_bindTo`. Сигнатуру его тоже посмотрим здесь:
```javascript
/**
 * Добавляет обработчик события `event` объекта `emitter`. Контекстом обработчика
 * является экземпляр данного блока. Обработчик события автоматически удалится при вызове
 * `Block.prototype.destruct()`.
 *
 * @protected
 * @param {jQuery|Block} emitter
 * @param {String} event
 * @param {Function} callback
 * @returns {Block}
 *
 * @example
 * var View = inherit(Block, {
 *     __constructor: function (model) {
 *         this.__base();
 *
 *         var hide = this._findElement('hide');
 *         this._bindTo(hide, 'click', this._onHideClick);
 *
 *         this._bindTo(model, 'change-attr', this._onAttrChange);
 *     }
 * });
 */
_bindTo: function (emitter, event, callback) {
    this._eventManager.bindTo(emitter, event, callback);
    return this;
}
```
Первый параметр — элемент или блок, на котором слушаем событие.

Второй параметр — строковое имя события.

Третий — функция-обработчик события. Вызовется, когда событие случится.

Тоже приватный метод. И тоже читается, как предложение на русском языке.

```javascript
    this._bindTo(clear, 'click', function () {
        console.log('Крестик нажат');
    });
    // У этого блока привяжи элемент clear к событию 'click', и когда оно случится, вызови функцию-обработчик.
}
```

Обновите страницу в браузере и нажмите мышкой на крестик. В консоли видим сообщение: "Крестик нажат"? Прекрасно.

В `JSDoc`-е к методу `_bindTo` есть примеры его вызова. Видно, что в примерах третий параметр — это не сама 
функция-обработчик, а только ссылка на неё. Сделаем у себя так же:

1. Отредактируйте третий параметр в методе `_bindTo`

2. Ниже конструктора добавьте метод `_onClearClicked` и напиши в нём какой-то новый `console.log`, чтобы убедиться, 
что изменения вступили в силу: 

Было:
```javascript
__constructor: function () {
    this.__base.apply(this, arguments);

    // 1. Найти элемент, сохранить на него ссылку.
    var clear = this._findElement('clear');
    
    // 2. Забиндить событие клика на нём и повесить обработчик клика.
    this._bindTo(clear, 'click', function () {
        console.log('Крестик нажат');
    });
}
```

Стало:

```javascript
__constructor: function () {
    this.__base.apply(this, arguments);

    // 1. Найти элемент, сохранить на него ссылку.
    var clear = this._findElement('clear');

    // 2. Забиндить событие клика на нём и повесить обработчик клика.
    this._bindTo(clear, 'click', this._onClearClicked);
},

_onClearClicked: function () {
    console.log('_onClearClicked: Крестик нажат');
},
```

Проверям. Если в консоли появилось сообщение: "_onClearClicked: Крестик нажат", значит успех.

Мы только что создали собственный приватный метод блока `Input`. Именно в нём мы будем очищать текстовое поле ввода.

Кстати, у нас же есть метод `setValue`, который предназначен для установки значения в текстовое поле. Воспользуемся 
им, только будем устанавливать пустую строку.

```javascript
_onClearClicked: function () {
    this.setValue('');
},
```

Проверяем, кликаем на крестик... и ничего не происходит. Это почему вдруг?

Ну, конечно, вот же ошибка. В методе `setValue` написано:
```javascript
setValue: function(value) {
    this.getDomNode().val(value);
}
```

Если я правильно помню, функция `val` — это `jQuery` функция, которая отлично устанавливает значение в текстовые поля 
формы. Проблема в том, что тот объект, который возвращает некий метод `this.getDomNode()`, не является `<input>`.  А 
что это такое вообще — `this.getDomNode()`?

Знакомьтесь, новый метод `YBlock` — метод `getDomNode`:
```javascript
/**
 * Возвращает DOM-элемент данного блока.
 *
 * @returns {jQuery}
 */
getDomNode: function () {
    return this._node;
}
```

Давайте проверим. Добавим `console.log` в метод `setValue`:

```javascript
setValue: function(value) {
    console.log(this.getDomNode());

    this.getDomNode().val(value);
}
```

В консоли вдруг видим `jQuery`-представление блока целиком, но никак не представление элемента `<input>`:

```javascript
{
    0: 'div.input_large._init',
    context: 'div.input_large._init',
    length: 1,
    selector: '',
    __proto__: x[0]
}
```
Получается, что мы пытаемся вызвать `jQuery`-функцию `val()` от DOM-элемента `<div class="input_large">...</div>`?


Ну да, мы же в файле [css.md](css.md) начинали с того, что блок 'input' был представлен только `DOM`-элементом `<input 
class="input_large">` и тогда же мы создавали `js`-заготовку, в которой описали метод `setValue()`. В тот момент этот 
метод работал правильно, потому что `this.getDomNode()` возвращал `jQuery`-представление текстового поля формы, и  
функция `val` работала корректно.
 
А чуть позже мы усложнили `HTML`-структуру блока, но `js`-код поправить забыли.

Вот как выглядит `HTML` блока сейчас:
```html
<div class="input_large _init" data-block="input">
    <input class="input_large__control" value="Привет, Бивис" name="loginField" placeholder="Инпут на сайте">
    <div class="input_large__clear"></div>
</div>
```

Следовательно, метод `setValue` (а так же `getValue`) должны работать не с `this.getDomNode()`, а с `DOM`-элементом 
поля формы. Текстовое поле формы у нас представлено тегом `<input class="input_large__control">` (см. `HTML` выше), то 
есть в терминах `BEViS` текстовое поле формы — это элемент `control` у блока `input-large` (см. атрибут 
`class="input_large__control"`).
 
Перепишем методы, чтобы значение извлекалось/устанавливалось в/из текстового поля формы:
```javascript
getValue: function() {
    var control = this._findElement('control');
    return control.val();
},


setValue: function(value) {
    var control = this._findElement('control');
    control.val(value);
}
```

Всё, теперь работает, текст удаляется, вместо него возникает плейсхолдер.

Сделаем код опрятнее, удалим диблирование, допишем комментарии. У меня это получилось так:
```javascript
modules.define(
    'input',
    ['inherit', 'block'],
    function (provide, inherit, YBlock) {
        var Input = inherit(YBlock, {
            __constructor: function () {
                this.__base.apply(this, arguments);

                // Находим все элементы блока
                this._clear = this._findElement('clear');
                this._control = this._findElement('control');

                // Обрабатываем клик по крестику
                this._bindTo(this._clear, 'click', this._onClearClicked);
            },

            /**
             * Очищает поле ввода
             */
            _onClearClicked: function () {
                this.setValue('');
            },

            /**
             * Получает значение из текстового поля
             *
             * @returns {String | undefined}
             */
            getValue: function() {
                return this._control.val();
            },

            /**
             * Устанавливает значение к текстовое поле
             * 
             * @param {String} value Переданное значение
             */
            setValue: function(value) {
                this._control.val(value);
            }
        }, {
            getBlockName: function () {
                return 'input';
            }
        });

        provide(Input);
});
```

Обратите, внимание, элементы `clear` и `control` я раньше сохранял в локальные переменные внутри конструктора, а 
сейчас сохраняю в полях Класса, чтобы во всех методах они были доступны.

Всё работает. Осталось только по-тихоньку дописывать нужную функциональность.

Посмотрим на эскиз дизайнера ещё раз.

<img src="http://bevis-ui.github.io/docs/images/input-design.png" width="557" height="539" />

Что нужно реализовать ещё:

* деактивацию контрола, чтобы не кликался; и обратную ей активацию, 
* установку фокуса, чтобы вокруг появлялось жёлтое свечение,
* наверное, стоит сделать обработку нажатия клавиши `Enter`, чтобы пользователь мог отправлять данные, не уходя из поля 

## Состояния блока

Для деактивации и для фокуса мы в стилях создавали специальные состояния `disabled` и `focused`, которые визуально 
делают блок соответственно неактивным или в фокусе.

Состояния в `BEViS` ставятся с помощью приватного метода `_setState`. Вот его сигнатура:

```javascript
/**
 * Устанавливает CSS-класс по имени и значению состояния.
 * Например, для блока `button` вызов `this._setState('pressed', 'yes')`
 * добавляет CSS-класс с именем `pressed_yes`.
 *
 * С точки зрения `BEM` похож на метод `setMod`, но не вызывает каких-либо событий.
 *
 * @protected
 * @param {String} stateName Имя состояния.
 * @param {String|Boolean} [stateVal=true] Значение.
 *                                         Если указан `false` или пустая строка, то CSS-класс удаляется.
 * @returns {Block}
 */
_setState: function (stateName, stateVal) {
    // ...
}
```

Состояния могут быть однословные, как здесь нам нужно — просто `_disabled` или просто `_focused`. А могут быть 
двусловные, например `_pressed_yes`. Этом метод позволяет создавать и те и другие, и даже удалять состояние. Но для 
удаления есть симметричный метод `_removeState` (приводить его сигнатуру здесь не буду, 
[можно посмотреть](https://github.com/bevis-ui/bevis-stub/blob/master/core/block/block.js) самому, когда возникнет 
необходимость).

Я написал эту функциональность, гляньте. Мне кажется, объяснять там уже особо нечего, вы всё поймёте и без подсказок 

```javascript
modules.define(
    'input',
    ['inherit', 'block'],
    function (provide, inherit, YBlock) {
        var Input = inherit(YBlock, {
            __constructor: function () {
                this.__base.apply(this, arguments);

                // Находим все элементы блока
                this._clear = this._findElement('clear');
                this._control = this._findElement('control');

                // Обрабатываем клик по крестику
                this._bindTo(this._clear, 'click', this._onClearClicked);

                // Слушаем события, которые выбросил <input>
                this._bindTo(this._control, 'keypress', this._onKeyPressed);
                this._bindTo(this._control, 'focus', this.focus);
                this._bindTo(this._control, 'blur', this.blur);
            },

            /**
             * Очищает поле ввода
             */
            _onClearClicked: function () {
                if (this.isEnabled()) {
                    this.setValue('');
                    this.focus();
                }
            },

            /**
             * Устанавливает значение к текстовое поле
             *
             * @param {String} value Переданное значение
             * @returns {Input}
             */
            setValue: function(value) {
                this._control.val(value);
                return this;
            },

            /**
             * Получает значение из текстового поля
             *
             * @returns {String | undefined}
             */
            getValue: function() {
                return this._control.val();
            },

            /**
             * Устанавливает фокус на поле ввода.
             *
             * @returns {Input}
             */
            focus: function () {
                if (this.isEnabled()) {
                    this._setState('focused');
                    this._control.focus();
                }
                return this;
            },

            /**
             * Удаляет фокус с поля ввода.
             *
             * @returns {Input}
             */
            blur: function () {
                this._removeState('focused');
                this._control.blur();
                return this;
            },

            /**
             * Возвращает `true`, если поле ввода активно.
             *
             * @returns {Boolean}
             */
            isEnabled: function () {
                return !this._getState('disabled');
            },

            /**
             * Деактивирует поле ввода.
             *
             * @returns {Input}
             */
            disable: function () {
                if (this.isEnabled()) {
                    this.blur();
                    this._control.attr('disabled', 'disabled');
                    this._setState('disabled');
                }
                return this;
            },

            /**
             * Активирует поле ввода.
             *
             * @returns {Input}
             */
            enable: function () {
                if (!this.isEnabled()) {
                    this._control.removeAttr('disabled');
                    this._removeState('disabled');
                }
                return this;
            },

            /**
             * В инпуте нажали кнопку "Enter"
             *
             * @param {Event} e
             */
            _onKeyPressed: function (e) {
                if (e.keyCode === 13) {
                    this.emit('input-submitted', {
                        value: this.getValue()
                    });
                }
            }

        }, {
            getBlockName: function () {
                return 'input';
            }
        });

        provide(Input);
});
```

Я уверен, вы всё поняли, даже это:
```javascript
_onKeyPressed: function (e) {
    if (e.keyCode === 13) {
        this.emit('input-submitted', {
            value: this.getValue()
        });
    }
}
```

Мы на инпуте слушаем событие `keypressed` и ловим момент, когда нажали клавишу `Enter` — код клавиши `Enter` равен 13. 
После этого генерим произвольное событие `input-submitted` (я его сам придумал) с помощью ещё одного метода, который  
унаследован от `YBlock`, а тот в свою очередь унаследовал его от класса `EventEmitter`. Документацию к этому классу 
и к его методам для работы с событиями 
[можно прочитать здесь](https://github.com/bevis-ui/bevis-stub/blob/master/core/event-emitter/event-emitter.js). 

## Эмитирование произвольного события 

Метод `emit` позволяет "выкинуть" любое произвольное событие. А тот блок, кому важно узнать об этом событие, на это 
событие подписывается, ждёт, а потом слышит его и как-то реагирует. Я не сразу понял, как кастомные события работают. 

Кассир в Макдональдсе выбрасывает вверх руку и кричит в воздух "Свободная касса!". И кто проворнее, кому больше надо,
 тот спешит к кассе и получает от кассира бургер.
 
 Здесь так же. Метод `emit` - тот же кассир. Он выбрасывает в воздух клич, в нашем случае он кричит, что, мол, на 
 инпуте произошёл так называемый `input-submitted`. И тот, кто ждёт такой клич (кто подписался на событие  
 `input-submitted`), получает от метода какие-то данные из второго параметра. В нашем случае получает объект  
 `{value: this.getValue()}`. Ясное дело, в объекте будет не функция `this.getValue()`, а результат её работы, то есть
   текст, введённый в поле.
 
 Ну, в самом деле, мы же не хотим (не должны хотеть) по нажатию на `Enter` отправлять данные прямо из кода инпута?  
 Инпуту в идеале не нужно знать ни куда отправлять, ни в каком виде эти данные должны идти. Мы вообще-то с вами даже не 
 какой-то конкретный инпут только что запрограммировали — мы описали Класс `Input`, на основе которого можно сделать 
  множество экземпляров этого класса, и каждый из них будет иметь свои поля `this._clear`, `this._control` и все 
  описанные выше методы.
  
  Поэтому по нажатию на `Enter` самое лучше, что инпут может сделать - это крикнуть в воздух - я сделал то-то, 
  заберите у меня данные. И пусть, кому надо, тот и забирает.
  
  А кому обычно нужны данные? В старом вебе, когда мы не умели использовать XMLHTTPRequest, мы писали в `HTML` формы,
   которые были представлены тегом `<form action="path-to-server-script">`. И по клику на кнопку сабмита, браузер 
   собирал данные из полей формы и отправлял по адресу, указанному в атрибуте `action`. 
   
Сейчас мы всё больше пишем `javascript`-приложения, данные с полей форм собираем с помощью `js` и отправляем их на 
сервер с помощью XMLHTTPRequest. Это я к тому, что тег `<form>` нам особо и не нужен теперь. Разве что в качестве  
фоллбека (а вдруг ещё есть пользователи, которые отключают `Javascript` в браузере?). А что нам точно нужно - так это 
js-компонент, который будет исполнять роль формы. Именно он будет подписываться на кастомное событие 
`input-submitted`, получать данные из него и дальше что-то делать (сейчас не суть важно что).
 
Создадим такой?

## Связываем несколько блоков в одно приложение

В терминале пишем:

```
make block
# Введите имя блока: form
```

Посмотрите, по адресу `blocks/form` появился новый блок. Его bt-шаблон уныл и в стилях ни строчки осмысленного 
кода. Пусть так и будет. Нам не нужны ни какие-то особенные шаблоны, ни стили. Нам интересно другое. И это так
 прекрасно, что я тороплюсь вам об этом рассказать.
 
Давайте отредактируем `pages/test-page/test-page.page.js`, чтобы у вас получилось как у меня:

```javascript
module.exports = function (pages) {
    pages.declare('test-page', function (params) {
        var options = params.options;
        return {
            block: 'page',
            title: 'test page',
            styles: [
                {url: options.assetsPath + '.css'}
            ],
            scripts: [
                {url: options.assetsPath + '.' + params.lang + '.js'}
            ],
            body: [
                {
                    block: 'form'
                }
            ]
        };
    });
};
```

Мы выбросили декларацию инпута и вместо него задекларировали форму. Можете быстро глянуть в браузере - там ничего нет. 
Зависимость не добавили!

Добавим зависимость к `form` в `pages/test-page/test-page.deps.yaml`, чтобы у вас получилось как у меня:

```
- page
- block: block
  elem: auto-init
- input
- form
```

Проверяем в браузере - да, теперь "форма" отредерилась.

Чтобы клиентский `js`-код работал, в `bt`-шаблон добавим строку `ctx.enableAutoInit();`

```javascript
module.exports = function (bt) {
    bt.match('form', function (ctx) {
        ctx.enableAutoInit();
        ctx.setTag('span');
        ctx.setContent('Содержимое блока');
    });
};
```
 
А теперь мы налету будем генерить `input`!
 
 Открываем `blocks/form/form.js` и пишем:

```javascript
modules.define(
    'form',
    ['inherit', 'block', 'input'],
    function (provide, inherit, YBlock, Input) {
        var form = inherit(YBlock, {
            __constructor: function () {
                this.__base.apply(this, arguments);

                // Создаём инпут
                this._greetingInput = new Input();

                // Рендерим форму
                this._render();
            },

            /**
             * Рендерит все контролы в форме
             */
            _render: function () {
                var form = this.getDomNode();
                var greeting = this._greetingInput.getDomNode();

                greeting.appendTo(form);
            }      
        }, {
            getBlockName: function () {
                return 'form';
            }
        });

        provide(form);
});
```
Смотрите внимательно, я в зависимостях указал модуль `input` (3-я и 4-я строки)

А потом в конструкторе формы очень красиво, коротко, понятно сказал:
```javascript
// Создаём инпут
this._greetingInput = new Input();
```

Как только я это сказал, тут же (в памяти браузера) возник новый экземпляр класса `Input` и сохранился в 
поле `_greetingInput`. 

А как только я "заапендил" этот экземпляр в `DOM` дерево, он тут же инициализовался и готов к работе.

И в браузере отобразился инпут, который умеет слушать клики на крестике, нажатие клавиши `Enter` и всё другое.

Красиво, коротко, понятно: `new Input()` и готово.

Если нужно наполнить поле значением, делаем это через публичные методы класса `Input`:

```javascript
// Создаём инпут
this._greetingInput = new Input();
this._greetingInput.setValue('Привет, Бивис!');
```

Можно тут же установить фокус или деактивировать поле, в-общем, делать всё то, для чего
 написаны публичные методы класса `Input`:
```javascript
this._greetingInput.focus();
this._greetingInput.disable();
```

И наконец, мы можем подписаться на произвольные события, генерируемые классом `Input`.

```javascript
// Создаём инпут
this._greetingInput = new Input();
this._greetingInput.on('input-submitted', this._onInputSubmitted, this);
```

## Подписка на произвольное событие

Подписка на произвольные события происходит с помощью метода `on()`, который вызывается от объекта, на котором мы хотим 
услышать событие. Этот метод есть у каждого визуального блока, потому что он наследован от класса `EventEmitter`.
 
Метод `on` тоже читается, словно на человеческом языке: 
```javascript
this._greetingInput.on('input-submitted', this._onInputSubmitted, this);
// Этот инпут-контрол слушает событие `input-submitted`, и когда оно случится, вызовется метод `_onInputSubmitted`
```
Обратите внимание, что во втором параметре метода `on` мы передаём только имя функции-обработчика, но не вызываем её.
  Скорее всего вы и сами это знаете, зачем я об этом толкую лишний раз? Но вдруг не лишним будет повторить. 
 
Вот так неправильно делать, не сработает, не делайте так:
```javascript
this._greetingInput.on('input-submitted', this._onInputSubmitted(), this);
// -------------------------------------------------------------^  Нельзя!
```

Довольно часто разработчики сайтов описывают тело обработчика события прямо в слушателе события. Это выглядит так: 
```javascript
this._greetingInput.on('input-submitted', function (e) {
    // здесь какая-то реакция на событие.
}, this);
```

Так пишут оооочень часто. Но если мы напишем в теле функции кода много, то такой код трудно читать и трудно 
поддерживать — фактически мы лепим в один комок и слушание событие и обработку события. 

Мы выносим тело обработчика в отдельный метод класса, а в методе `on` указываем только имя обработчика. 
Получается ровно то же самое, только опрятнее. Сравните сами эти два фрагмента:

```javascript
__constructor: function () {
    this._greetingInput.on('input-submitted', function (e) {
        // здесь какая-то реакция на событие.
    }, this);
}
```

И

```javascript
__constructor: function () {
    this._greetingInput.on('input-submitted', this._onInputSubmitted, this);
},

_onInputSubmitted: function (e) {
    // здесь какая-то реакция на событие.
}
```

Мы предпочитаем второй путь, он читабельнее.

Что будет происходить в обработчике - на ваше усмотрение. У меня обработчик пока только вываливает в консоль 
сообщение об `Event`-е и о данных, которые в обработчик пришли из второго параметра метода `emit`. У вас там 
наверняка будет валидация данных во всех полях формы и отправка данных куда-то в бекенд.

```javascript
modules.define(
    'form',
    ['inherit', 'block', 'input'],
    function (provide, inherit, YBlock, Input) {
        var form = inherit(YBlock, {
            __constructor: function () {
                this.__base.apply(this, arguments);

                // Создаём инпут
                this._greetingInput = new Input();
                this._greetingInput.on('input-submitted', this._onInputSubmitted, this);

                // Рендерим форму
                this._render();
            },

            /**
             * Реагирует на нажатие клавиши Enter в `Input`
             * @param {YEventEmitter} e
             */
            _onInputSubmitted: function (e) {
                console.log('Форма поймала событие на Input = ', e);
            },

            /**
             * Рендерит все контролы в форме
             */
            _render: function () {
                var form = this.getDomNode();
                var greeting = this._greetingInput.getDomNode();

                greeting.appendTo(form);
            }
        }, {
            getBlockName: function () {
                return 'form';
            }
        });

        provide(form);
});
```

## Обработка произвольного события и получение данных из эмиттера

Когда метод `emit` выкинет вверх событие `input-submitted`, он заодно передаст слушателю некие данные. Помните 
второй параметр? Мы с вами эмитили событие и передавали некий объект с полем `value`:

```javascript
this.emit('input-submitted', {
    value: this.getValue()
});
```

А когда метод `on` слышит это событие, он вызывает функцию `_onInputSubmitted`. Но не просто вызывает, а ещё передаёт в
 неё некий специальный объект - `Event`. 

_Это вообще-то обычное дело, что я тут объясняю?! Коллбек-обработчик всегда получает единственный параметр `Event`._ 

Поэтому обработчик ждёт в аргументах вызова этот объект. Традиционно его принято принимать в переменную `e`. Мы и 
принимаем:
 
```javascript
/**
 * Реагирует на нажатие клавиши Enter в `Input`
 * @param {YEventEmitter} e
 */
_onInputSubmitted: function (e) {
    console.log('Форма поймала событие на Input = ', e);
}
```    

Его можно не принимать, то есть убрать аргумент `e` из круглых скобок. Тогда метод `on` всё равно будет 
передавать его в `_onInputSubmitted`, но метод `_onInputSubmitted` принимать евент не будет. А вообще принимать его 
стоит :)
  
Если мы сейчас посмотрим в браузер (обновив страницу, конечно), кликнем в инпут и нажмём `Enter`, в консоли появится 
сообщение: 
```javascript
Форма поймала событие на Input = {
    _isDefaultPrevented: false,
    _isPropagationStopped: false,
    _jqEvent: x.Event,
    data: {
        value: "Привет, Бивис"
    },
    target: res,
    type: "input-submitted",
    __proto__: res
}
```
Мы смотрим на объект `YEventEmitter` — тот самый евент, который приходит в каждый обработчик события. В нём мы видим 
поле `data`, в котором оказались те данные, что отдал `Input`, когда эмитил событие. Мы видим тип события в поле 
`type`. Мы видим поле `target`, в котором хранится ссылка на объект, который и вызвал само событие — `DOM`-нода с 
инпутом.  

Именно так мы передаём данные в обработчики.

Теперь я смотрю на код и мне почти всё нравится.

Не нравится только, что модуль с формой занимается `append`-ом инпута внутрь себя. Мне кажется, форма этим заниматься не
 должна. Инпут сам должен рендерить себя — пусть рендеринг инпута происходит в модуле `Input`, а не в модуле `Form`. 
  Не могу аргументированно доказать, почему именно такой подход я считаю правильным, но я ему следую. "Я художник — 
  я так вижу" (с) 
  
Есть по-сильнее аргумент. Если инпут будет уметь сам себя рендерить, тогда он может оказаться в любом другом блоке, а
  не только в _этой_ форме — любой блок сможет создать инстанс Инпута и не заботиться о том, что нужно ещё 
написать некий метод, чтобы встроить этот инпут в себя. Хочется, чтобы инпут умел принимать параметр со ссылкой на 
"родительскую" `DOM`-ноду, куда инпуту нужно встроиться.  

Для этого нам пригодится возможность в конструктор класса передавать параметры.

## Передача параметров в конструктор Класса

```javascript
modules.define(
    'form',
    ['inherit', 'block', 'input'],
    function (provide, inherit, YBlock, Input) {
        var form = inherit(YBlock, {
            __constructor: function () {
                this.__base.apply(this, arguments);

                var formDomNode = this.getDomNode();

                // Создаём инпут
                this._greetingInput = new Input({
                    parentNode: formDomNode
                });

                this._greetingInput.on('input-submitted', this._onInputSubmitted, this);
            },

            _onInputSubmitted: function () {
                console.log('Форма поймала событие от Input');
            }
        }, {
            getBlockName: function () {
                return 'form';
            }
        });

        provide(form);
});
```

1. Мы удалили метод `render()`. Он не нужен.

2. В конструкторе формы мы создали локальную переменную `formDomNode`, в которую получили `DOM`-представление формы.

3. В создаваемый экземпляр класса `Input` мы передали произвольный параметр `parentNode`, в значении которого 
оказалось `DOM`-представление формы. Имя `parentNode`, как и `formDomNode` - абсолютно произвольные. 

Было:
```javascript
// Создаём инпут
this._greetingInput = new Input();
```

Стало:
```javascript
// Создаём инпут
this._greetingInput = new Input({
    parentNode: formDomNode
});
```

Код модуля `Form` стал меньше и понятнее. В нём не осталось никакой лишней логики, есть только нужное для формы: 
* создаёт экземпляр инпута
* если инпут выкинет событие `input-submitted` — форма отреагирует каким-то образом. 

А код модуля `Input` нужно дописать:
* принимать в конструкторе параметр `parentNode`, в котором хранится `DOM`-представление формы
* "заппендить" инпут внутрь формы 

Смотрите, что я изменил в модуле `input.js`:

Было:
```javascript
__constructor: function (params) {
    this.__base.apply(this, arguments);

    // Находим все элементы блока
    this._clear = this._findElement('clear');
    this._control = this._findElement('control');

    // Обрабатываем клик по крестику
    this._bindTo(this._clear, 'click', this._onClearClicked);

    // Слушаем события, которые выбросил <input>
    this._bindTo(this._control, 'keypress', this._onKeyPressed);
    this._bindTo(this._control, 'focus', this.focus);
    this._bindTo(this._control, 'blur', this.blur);
},
```

Стало:
```javascript
__constructor: function (params) {
    this.__base.apply(this, arguments);

    // Получаем параметр с DOM-нодой родителя.
    this._parentNode = params.parentNode;

    // Отредери себя!
    this._render();
    
    // Находим все элементы блока
    this._clear = this._findElement('clear');
    this._control = this._findElement('control');

    // Обрабатываем клик по крестику
    this._bindTo(this._clear, 'click', this._onClearClicked);

    // Слушаем события, которые выбросил <input>
    this._bindTo(this._control, 'keypress', this._onKeyPressed);
    this._bindTo(this._control, 'focus', this.focus);
    this._bindTo(this._control, 'blur', this.blur);
},

/**
 * Рендерит инпут внутри родительской DOM-ноды this._parentNode
 */
_render: function () {
    this.getDomNode().appendTo(this._parentNode);
},
```

Так можно передавать любые параметры из одного блока в другой. Так блоки могут обмениваться данными. 

Но это ещё не всё. Ведь можно в конструктор инпута передавать параметры, как мы это делали в bt-шаблоне.

Помните, мы в `test-page.page.js` когда-то декларировали статический `btjson`, а позже от него отказались?
```javascript
    body: [
        {
            block: 'input',
            view: 'large',
            value: 'Привет, Бивис',
            name: 'loginField',
            placeholder: 'Инпут на сайте'
        }
    ]
```

Точно такой же статический `btjson` можно передавать в качестве параметров при создании экземпляра нашего Инпута.

Возвращаемся в модуль `form.js`

Было:
```javascript
// Создаём инпут
this._greetingInput = new Input({
    parentNode: formDomNode
});
```

Стало:
```javascript
// Создаём инпут
this._greetingInput = new Input({
    value: 'Привет, Бивис',
    name: 'loginField',
    placeholder: 'Инпут на сайте',

    parentNode: formDomNode
});
```

И обновите страницу в браузере.
 
Внезапно, в текстовом поле оказалось значение "Привет, Бивис". А если фаербагом посмотреть в `HTML`, увидим в атрибуте 
`name` значение "loginField", а в `placeholder` значение "Инпут на сайте". 

И при этом инпут отрендерился внутри формы (сам!), на нёго повесились все обработчики событий.
И при этом форма слушает его кастомные события.

Я очень люблю `BEViS` за это. Оказывается, `bt`-шаблоны работают и на серверной стороне и в браузере. И мы можем 
использовать аж целых три способа для генерации блоков на странице.


## Три способа генерации блока

### Способ №1. Статический

Если надо создать блок на серверной стороне, мы в теле страницы `test-page.page.js` декларируем блок и 
описываем нужные опции. Вот фрагмент страницы `test-page.page.js` со статической декларацией блока `input`.
```javascript
body: [
    {
        block: 'input',
        view: 'large',
        value: 'Привет, Бивис',
        name: 'loginField',
        placeholder: 'Инпут на сайте'
    }
]
```
И знаем, что сервер отправит браузеру полностью готовый код блока в виде набора `HTML`-тегов со 
всеми нужными данными для отображения.

### Способ №2. Динамический с использованием btjson

Если надо создать не статический блок (когда все данные для блока известны), а динамический (когда часть данных может
  быть известна только во время работы приложения в браузере) из клиентского `javascript`, то нам нужно выполнить два
    шага:

* Создать файл-болванку для клиентского `javascript`-модуля (можно сделать с помощью команды `make block`)
    ```javascript
    modules.define(
        'input',
        [
            'inherit',
            'block'
        ],
        function (
            provide,
            inherit,
            YBlock
        ) {
            var Input = inherit(YBlock, {
                __constructor: function () {
                    this.__base.apply(this, arguments);
                }
            }, {
                getBlockName: function () {
                    return 'input';
                }
            });
    
            provide(Input);
        }
    );
    ```
Этой болванки абсолютно достаточно, чтобы выполнить второй шаг.

* В каком-то другом модуле (например `form.js`) вызвать конструктор класса `Input` с `bt`-опциями, которые можно 
заполнить динамическими данными:
    ```javascript
    // Создаём инпут
    var currentValue = 'Привет, Бивис'; // Здесь, например, вызов некоей функции, которая вернёт некое значение для поля.
    var currentName = 'loginField'; 
    
    this._greetingInput = new Input({
        value: currentValue,
        name: currentName,
        placeholder: 'Инпут на сайте',
    });
    ```

В результате работы конструктора `new Input` в памяти браузере возникнет `HTML` инпута прямо налету. И получить 
его можно с помощью метода `getDomNode()`: `this._greetingInput.getDomNode()`.
  
А дальше этот `HTML` нужно "заппендить" в `DOM`-дерево страницы каким-то образом - на ваше усмотрение. Наши  
предпочтения на этот счёт я описал выше.

И есть ещё один способ генерации блока на стороне браузера.

### Способ №3. Динамический с использованием публичных методов блока

Мы можем не полагаться на `bt`-шаблоны, а описать в `input.js` специальные методы-сеттеры (от слова 'to set' -  
устанавливать), с помощью которых можно установать необходимые значения. Мы с такого метода начинали с вами: это 
метод `setValue()`. И в каком-то другом модуле (например `form.js`) после вызова конструктора класса `Input` 
вызывать именно методы-сеттеры, чтобы заполнить инпут данными:
 
```javascript
this._greetingInput = new Input();
this._greetingInput.setValue('Привет, Бивис!');
```

Мы в Яндекс.Картах пользуемся всеми тремя способами одновременно: что можно сгенерить статически - генерим на 
сервере; если какие-то данные для генерации блока мы можем получить только в браузере, мы генерим блок динамически.

Строго говоря, есть ещё один способ создавать бивис-блоки налету. Мы не то, что не рекомендуем его. Нет, пользоваться
 вполне можно. Мы им пользуемся редко — так редко, что я даже не приведу вам ни одного случаю по памяти. Вот он:

### Способ № NaN. Динамический с использованием `bt.apply`

```javascript
var inputDomNode = bt.apply({
    block: 'input',
    view: 'large',
    value: 'Привет, Бивис',
    name: 'loginField',
    placeholder: 'Инпут на сайте'
});
```
В переменной `inputDomNode` сохранится `HTML` блока `input`.
 
Точно так же можно создавать элементы блока, если в опциях указать поле `elem`:

```javascript
var inputClearDomNode = bt.apply({
    block: 'input',
    elem: 'clear' // <-------- Мы создаём элемент `clear`
});
```

Обратите внимание, метод `apply` возвращает именно `HTML` блока или элемента, но в виде строки (типа `String`). Не 
знаю, зачем вам это может понадобиться. Я не могу сходу вспомнить ни одного случая, когда это мне было нужно.

## Динамическая генерация элемента блока

Есть более правильный способ создавать элементы блока. Это метод `_createElement`, который наследуется от класса 
`YBlock`. Вот его сигнатура:
```javascript
/**
 * Создает и возвращает DOM-элемент элемента блока на основе BT-опций.
 * Создание нового элемента осуществляется с помощью применения BT-шаблонов.
 *
 * @protected
 * @param {Object|String} params BT-опции или имя элемента.
 * @returns {jQuery}
 */
_createElement: function (params) {
    if (typeof params === 'string') {
        params = {elem: params};
    }
    return $(bt.apply(extend(
        {view: this.getView()},
        params,
        {block: this.__self.getBlockName()}
    )));
}
```

Внутри него мы видим тот же `bt.apply`, только его результат завёрнут в `jQuery`. 
Когда такой метод нужен?

Например, я хочу налету сгенерить под инпутом новый элемент. Почему это не сделать статически, спросите вы? А я не 
знаю, нет причины. Захотелось! Просто захотелось именно этот элемент генерить полностью динамически. Вот как я могу это 
сделать:

```javascript
__constructor: function (params) {
    this.__base.apply(this, arguments);
    
    // Получаем параметр с DOM-нодой родителя.
    this._parentNode = params.parentNode;

    // Отредери себя!
    this._render();
    
    this._hint = this._createElement({
        elem: 'hint'
    });

    this._renderHint();

    // ...
},

/**
 * Рендерит подсказку внутри инпута
 */
_renderHint: function () {
    this._hint.appendTo(this.getDomNode());
}
```

Обратите внимание, от элемента блока нет нужды брать `getDomNode`, потому что метод `this._createElement` вернул в 
поле `this._hint` не что иное, как `jQuery`-представление элемента.  

Обновим страницу в браузере и посмотрим в файрбаге на созданный элемент:

```html
<div class="input_large _init" data-block="input">
    <input class="input_large__control" value="Привет, Бивис" name="loginField" placeholder="Инпут на сайте">
    <div class="input_large__clear"></div>
    <div class="input_large__hint"></div>
</div>
```

У нашего Класса `Input` есть метод, о которм мы ещё не говорили — `getBlockName`.
Судя по всему, метод публичный, доступный другим блокам для использования. Но почему он лежит в третьем параметре 
функции `inherit`? И зачем он нужен в каждом блоке? Напомню вам, что как только мы в терминале ввели команду `make 
block`, на файловой системе возник файл `blocks/input/input.js` с таким содержимым: 
 
```javascript
modules.define(
    'input',
    [
        'inherit',
        'block'
    ],
    function (
        provide,
        inherit,
        YBlock
    ) {
        var Input = inherit(YBlock, {
            __constructor: function () {
                this.__base.apply(this, arguments);
            }
        }, {
            getBlockName: function () {
                return 'input';
            }
        });

        provide(Input);
    }
);
```

Мы с вами говорили о том, что такое функция `inherit`; говорили, как устроены первый и второй её аргументы; но ничего
 не сказали про третий аргумент. Говорим теперь, самое время.

## Статические методы класса

Третий аргумент - это объект с так называемыми `статическими методами класса`. Статические методы класса это такие 
методы, к которым можно обратиться не создавая объект данного класса. Это такие методы, которые присущи не 
конкретному объекту, а классу целиком.

Попробую объяснить это так, как понял бы я сам.

Есть Класс `Input`. Описан в файле `input.js`. Есть Класс `form.js`, описан в файле `form.js`. Внутри класса `Form` 
мы всегда создавали только один экземпляр класса `Input`:
```javascript
// Создаём инпут
this._greetingInput = new Input({
    value: 'Привет, Бивис',
    name: 'loginField',
    placeholder: 'Инпут на сайте',

    parentNode: formDomNode
});
```

При этом в памяти браузера создавалась новая переменная `this._greetingInput`, под которую компьютер отводил 
сколько-то байт памяти. Сколько? Я думаю, столько, чтобы уместить в памяти все методы, которые экземпляр инпута 
получил из Класса `Input`. Прямо сейчас `this._greetingInput` представлен в памяти браузера объектом с 12 
динамическими методами и 1 статическим (тот самый `getBlockName`). Значит памяти будет занято столько, чтобы 
уместилось 12 динамических методов и 1 статический.
 
А что будет с памятью компьютера, когда мы в файле `form.js` создадим два экземпляра Класса `Input`? Например, 
первый инпут для логина, а второй для пароля:

```javascript
// Создаём инпут для логина
this._greetingInput = new Input({
    value: 'Привет, Бивис',
    name: 'loginField',
    placeholder: 'Инпут на сайте',
    parentNode: formDomNode
});

// Создаём инпут для пароля
this._passwordInput = new Input({
    name: 'passwordField',
    parentNode: formDomNode
});
```

Количество занимаемых байт в памяти увеличится почти вдвое, потому что для динамических методов и свойств отводится 
своё собственное место. Значит в памяти будет занято столько байт, чтобы уместилось уже 24 динамических метода и ... 
1 статический метод (тот самый `getBlockName`).

Будет три экземпляра инпута — память будет раходоваться на 36 динамических методов и ... 1 статический.
  
Значит, чем больше объектов с динамическими методами мы создадим, тем больше памяти будет использоваться, тем больше 
будет трудиться процессор компьютера и тем громче будет шуметь кулер на вашем ноутбуке.

В отличие от динамических методов, статические методы не копируются в каждый объект. Они существуют в памяти 
компьютера в единственном экземпляре. Мне представляется, что статические методы - это способ экономить память, а 
значит делать приложение менее ресурсоёмким, а это в свою очередь даёт прирост в скорости работы приложения. 

Метод `getBlockName` — первый статический класс, который мы много раз видели в наших модулях. Он нужен чисто для 
служебных целей. Я вам не растолкую, для каких именно — сам не очень понимаю, да мне и не нужно. Главное, что следует 
знать — это две вещи:
* в вашем модуле этот метод должен всегда быть всегда
* он должен возвращать точно такую же строку, что записана в имени модуля  
```javascript
modules.define(
    'input', // <------------------------------- Здесь!
    ['inherit', 'block'],
    function (provide, inherit, YBlock) {
        var Input = inherit(YBlock, {
        }, {
            getBlockName: function () {
                return 'input'; //  <----------- Здесь!
            }
        });

        provide(Input);
    }
);
```

В этом примере на строке №2 и строке №9 мы видим одно и то же строковое значение `input`. Так и должно быть. Это 
нужно для поиска модуля в некоем хранилище всех модулей. Детальнее я вам не отвечу, приходится просто запомнить.
 
Интересно другое. Вы можете создавать в своих классах какие угодно статические методы. Для примера создадим 
статический метод для проверки, что пользователь ввёл в инпут более-менее реальный текст, а не пробельные символы. 

Добавим в секцию со статическими методами ещё один новый.

Было:
```javascript
getBlockName: function () {
    return 'input';
}
```

Стало:
```javascript
getBlockName: function () {
    return 'input';
},

/**
 * Проверяет значение в инпуте — есть в нём какие-то символы, кроме пробельных
 *
 * @static
 * @param {String} text Текст, который нужно проверить
 * @returns {Boolean}
 */
isNotEmpty: function (text) {
    var clearText = text.replace(/^\s+|\s+$/gi, '');
    return Boolean(clearText);
}
```

Вернитесь в `form.js` и проверьте, есть ли у переменной `this._greetingInput` такой метод
```javascript
console.log(this._greetingInput.isNotEmpty);
```

Я вижу в консоли сообщение: `undefined`. Нет такой функции у объекта, хранимом в переменной `this._greetingInput`!
                                                                                   
А теперь проверим, есть ли у Класса `Input` такой метод:
```javascript
console.log(Input.isNotEmpty);
```
И консоль показала мне содержимое функции `isNotEmpty`. Эта функция принадлежит классу `Input` и только ему.

Статическими методами можно пользоваться где угодно. Я, к примеру, в файле `input.js` добавил такую проверку:

Было:
```javascript
/**
 * В инпуте нажали кнопку "Enter"
 *
 * @param {Event} e
 */
_onKeyPressed: function (e) {
    if (e.keyCode === 13) {
        this.emit('input-submitted', {
            value: this.getValue()
        });
    }
}
```

Стало:
```javascript
/**
 * В инпуте нажали кнопку "Enter"
 *
 * @param {Event} e
 */
_onKeyPressed: function (e) {
    var text = this.getValue();

    if (e.keyCode === 13 && Input.isNotEmpty(text)) {
        this.emit('input-submitted', {
            value: text
        });
    }
}
```

[`YBlock`](https://github.com/bevis-ui/bevis-stub/blob/master/core/block/block.js) кроме непонятного метода`getBlockName` предоставляет несколько полезных удобных статических методов.  Каждый
 такой метод помечен в `JSDoc` тегом `@static`. Обязательно посмотрите на такие методы как `findAll`, `find`, 
 `initDomTree`. К каждому методу описан пример, там всё понятно.

## Инициализация блоков

Метод `initDomTree` — очень важный метод. Без него ни один наш компонент не был бы инициализирован - ни форма, ни 
инпут. Именно он отвечает за то, чтобы в `bevis-stub` инициализировать наши бивис-блоки. 

Где он вызывается? Откройте файл `core/block/block__auto-init.js`:
```javascript
modules.require(['jquery', 'block'], function ($, Block) {
    $(function () {
        Block.initDomTree(window.document).done();
    });
});
```
Мы видим `ymaps-модуль`, но какой-то странный: вместо `modules.define` использован `modules.require`.
[Читаем документацию](https://github.com/ymaps/modules/blob/master/README.ru.md#Объявление-модуля). Значит это не 
объявление модуля, а использование. Другими словами, код этого модуля выполнится сразу, как только 
`Javascript`-интерпретатор его прочитает. Именно этот файл - точка входа в работу нашего javascript-bevis-приложения.
 И работает это так:

"Слушай меня, `Javascript`-интерпретатор", — говорит модульная система. — "Как только я (модульная система) загружу 
модули `jquery` и `block`, сразу выполни следующий код":

```javascript
    $(function () {
        Block.initDomTree(window.document).done();
    });
```

То есть, вызови `jQuery`-функцию, которая выполнит строку:
 
```javascript 
        Block.initDomTree(window.document).done();
``` 

А в этой строке от модуля `YBlock` вызывается статический метод `initDomTree`, который иницилизирует все 
бивис-компоненты внутри ноды `window.document`. 

Слово "инициализирует" - означает, что:
 
1. Бивис начинает обходить всё дерево документа и встречает в нём, к примеру, самую первую ноду `<div class="form">`.
 
2. После этого Бивис находит `js`-модуль, соответствующий этой ноде, — `modules.define( 'form', //...);`.
 
3. Заходит в модуле в метод `__constructor` и последовательно выполняет все его инструкции. 

4. И так происходит для каждого бивис-блока, который есть в дереве документа — инициализируется все подряд. 

Файл `core/block/block__auto-init.js` попадает в собранный `test.ru.js` благодаря тому, что в зависимостях страницы 
`pages/test-page.deps.yaml` мы позвали этот блок (вот он, второй сверху):
```
- page
- block: block
  elem: auto-init
- input
- form
```

Этот способ имеет недостаток — он инициализирует _все_ блоки на странице. Если приложение большое, блоков на странице 
много, то сразу займётся много памяти компьютера. И при этом не факт, что все блоки будут задействованы на 
странице. 

Например, на странице есть две формы — форма авторизации и форма обратной связи. Они представлены разными блоками, и 
каждая делает свой сабмит с перезагрузкой страницы. Очевидно, пользователь воспользуется только одной из форм. Зачем 
тогда инициализировать обе формы, нагружать память компьютера методами обеих форм, если только одна из них отработает на 
странице?

Есть альтернативный способ инициализировать блоки. "Инициализация по требованию", "отложенная" или "живая 
инициализация".

## Живая инициализация блоков

Смысл в том, чтобы инициализировать блок только тогда, когда пользователь начал работать с блоком. На странице с 
двумя формами это могло бы выглядеть так: если пользователь поставил курсор в текстовое поле формы авторизации и 
начал там что-то писать, тогда инициализировать форму авторизации **надо** (чтобы желтая рамка вокруг поля возникла, 
чтобы крестик слушал на себе клик, чтобы по нажатию на `Enter` выбрасывалось кастомное событие...). А вторая форма при 
этом остаётся неинициализирована, спит до тех пор, пока пользователь не начнёт совершать какие-то действия над её 
элементами.

Если мы пишем маленькое-малюсенькое приложение, если блоков у нас немного, то этим можно не заниматься. Но если мы 
разрабатывает приложение большое, с большим количеством логики, то позаботиться о производительности приложения стоит.
 
В `BEViS` живая инициализация происходит с помощью статического метода `_liveInit`. Вот его документация из `YBlock`:
```javascript
/**
 * Если для блока требуется отложенная (`live`) инициализация,
 * следует перекрыть это свойство статическим методом.
 *
 * Этот выполняется лишь однажды, при инициализации первого блока на странице.
 *
 * В рамках `_liveInit` можно пользоваться методами `_liveBind` и `_liveBindToElement` для того,
 * чтобы глобально слушать события на блоке и элементе соответственно.
 *
 * @static
 * @protected
 * @type {Function|null}
 *
 * @example
 * var MyBlock = inherit(YBlock, {}, {
 *     _liveInit: function () {
 *         this._liveBind('click', function(e) {
 *             this._setState('clicked', 'yes');
 *         });
 *         this._liveBindToElement('title', 'click', function(e) {
 *             this._setElementState($(e.currentTarget), 'clicked', 'yes');
 *         });
 *     }
 * });
 */
_liveInit: null
```

По умолчанию этот метод определён в `null`. Если он вам нужен - переопределяйте его в своих блоках. К примеру 
элементы инпута можно было бы инициализировать отложенно:

```javascript
modules.define(
    'input',
    ['inherit', 'block'],
    function (provide, inherit, YBlock) {
        var Input = inherit(YBlock, {
            __constructor: function (params) {
                // ...
                
                // Обрабатываем клик по крестику
                //this._bindTo(this._clear, 'click', this._onClearClicked);

                // Слушаем события, которые выбросил <input>
                //this._bindTo(this._control, 'keypress', this._onKeyPressed);
                //this._bindTo(this._control, 'focus', this.focus);
                //this._bindTo(this._control, 'blur', this.blur);
            },

            // ...
        }, {
            _liveInit: function () {
                this._liveBindToElement('clear', 'click', function() {
                    this._onClearClicked();
                });
                this._liveBindToElement('control', 'keypress', function(e) {
                    this._onKeyPressed(e);
                });
                this._liveBindToElement('control', 'focus', function() {
                    this.focus();
                });
                this._liveBindToElement('control', 'blur', function() {
                    this.blur();
                });
            },

            getBlockName: function () {
                return 'input';
            },

            // ...
        });

        provide(Input);
});
```
Я создал статический метод `_liveInit`, в него перенёс слушание событий на элементах. Работает. 

Надо? Пользуйтесь.

## Наследование своих же блоков

Про механизм наследования, кажется, нужно ещё раз рассказать. Как вы знаете, мы наследуем классы через функцию 
`inherit`. До сих пор мы создавали блоки (`form`, `input`) и наследовали их от класса `YBlock`. Точно таким же 
образом можно наследоваться от наших же собственных блоков - от того же `form` и `input`.

Создадим файл `blocks/super-input/super-input.js`. Это будет новый блок, некий "Супер-Инпут", который отнаследует все 
возможности "Инпута", и переопределит какие-то методы "Инпута" или добавит какие-то свои собственные методы:
```javascript
modules.define(
    'super-input', // <----- Имя модуля
    [
        'inherit', 
        'input' // <-------- Зависимость от модуля `input`
    ],
    function (
        provide, 
        inherit, 
        Input  // <--------- Получили модуль `input` в переменную `Input`
    ) {
        var SuperInput = inherit(Input, { // <--------------------- Отнаследовали `SuperInput` от `Input`
            __constructor: function (params) {
                this.__base.apply(this, arguments);
            },

            // Переопределили метод класса Input
            focus: function () {
                console.log('Метод focus переопределён!'); // <-- Добавили какую-то дополнительную функциональность

                this.__base.call(); // <---------- Вызвали базовый метод `focus` из родитеского класса `Input`
            },

            // Доопределили новый метод
            animate: function () {
                console.log('Метод animate доопределён!'); 
            }
        });

        provide(SuperInput);
});
```

Обязательно укажем этот модуль в зависимостях страницы `pages/test-page/test-page.deps.yaml`:

Было:
```
- page
- block: block
  elem: auto-init
- input
- form
```

Стало:
```
- page
- block: block
  elem: auto-init
- input
- super-input
- form
```

И теперь позовём этот "Супер-Инпут" внутри формы `block/form/form.js`, словно это обычный "Инпут":

```javascript
modules.define(
    'form',
    [
        'inherit', 
        'block', 
        'input', 
        'super-input'
    ],
    function (
        provide, 
        inherit, 
        YBlock, 
        Input, 
        SuperInput
    ) {
        var form = inherit(YBlock, {
            __constructor: function () {
                this.__base.apply(this, arguments);

                var formDomNode = this.getDomNode();

                // Создаём инпут
                this._greetingInput = new Input({
                    value: 'Привет, Бивис',
                    name: 'loginField',
                    placeholder: 'Инпут на сайте',

                    parentNode: formDomNode
                });
                this._greetingInput.on('input-submitted', this._onInputSubmitted, this);

                // Создаём инпут для пароля
                this._passwordInput = new SuperInput({ // <-------------------------- Создаём Супер-Инпут
                    name: 'passwordField',
                    type: 'password',
                    placeholder: 'Введите пароль',

                    parentNode: formDomNode
                });
                this._passwordInput.on('input-submitted', this._onInputSubmitted, this);
            },

            /**
             * Реагирует на нажатие клавиши Enter в `Input`
             * @param {YEventEmitter} e
             */
            _onInputSubmitted: function (e) {
                console.log('Форма поймала событие на Input = ', e);
            }
        }, {
            getBlockName: function () {
                return 'form';
            }
        });

        provide(form);
});
```

Обновим страницу в браузере и увидим два инпута рядом друг с другом — один для логина, второй для пароля. Если 
поставим курсор в поле для пароля, в консоли появится текст из переопределенного метода `focus`. При этом мы не 
писали для "Супер-Инпута" ни строчки шаблонов и стилей, они все приехали из "Инпута".

Следующими шагами практикума будут ["Как настроить локализацию?"](i18n.md) и 
["Как использовать MVC-паттерн в BEViS?"](mvc-app.md). Эти темы имеют прямое отношение к клиентскому 
`Javascript`, но знакомиться мы с ними будем в отдельных статьях.

Блоки `Input`, `Form` и `SuperInput` в том виде, в которм мы их приготовили в этой статье, вы можете увидеть в 
отдельной ветке [bevis-stub/tree/input-and-form](https://github.com/bevis-ui/bevis-stub/tree/input-and-form).

Сделаем перерыв и узнаем, как мы локализуем проекты? Я жду вас [здесь](i18n.md).
