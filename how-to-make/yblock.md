в разработке

----

Мы с вами проделали уже большой путь — [создали новую страницу](new-page.md),
[создали новый блок и написали простые bt-шаблоны](new-block.md),
[написали к блоку стили и расширили bt-шаблоны](css.md).

У нас есть страница `/pages/test-page/test-page.page.js`, а в ней единственный блок `input`:

```javascript
module.exports = function (pages) {
    pages.declare('test-page', function (params) {
        var options = params.options;
        return {
            block: 'page',
            title: 'test page',
            styles: [
                {url: options.assetsPath + '.css'}
            ],
            scripts: [
                {url: options.assetsPath + '.js'}
            ],
            body: [
                {
                    block: 'input',
                    view: 'large',
                    value: 'Привет, Бивис',
                    name: 'loginField',
                    placeholder: 'на сайте'
                }
            ]
        };
    });
}
```

Если проект запустить, то по адресу `http://localhost:8080/test` мы увидим страницу с серым фоном и текстовым полем,
в котором уже введено значение "Привет, Бивис".

Если в браузере заглянуть в `HTML`-код блока, увидим следующую структуру:

```html
<div class="input_large _init" data-block="input">
    <input class="input_large__control" value="Привет, Бивис" name="loginField" placeholder="Инпут на сайте">
    <div class="input_large__clear"></div>
</div>
```

Созданием этого `HTML`-кода занимаются `bt`-шаблоны, которые мы с вами написали в файле `/blocks/input/input.bt.js`.
Стилизацией блока занимается целая система файлов `/blocks/input/input*.styl`.

Самое время запрограммировать поведение блока — cделать блок интерактивным, т.е. отзывчивым на действия пользователя.

Когда мы [создавали новый блок](new-block.md), мы сделали заготовку для клиенсткого программирования. Вот она:

`/blocks/input/input.js`

```javascript
modules.define(
    'input',
    ['inherit', 'block'],
    function (provide, inherit, YBlock) {
        var Input = inherit(YBlock, {
            __constructor: function () {
                this.__base.apply(this, arguments);

                console.log(this.getValue());
            },

            getValue: function() {
                return this.getDomNode().val();
            },


            setValue: function(value) {
                this.getDomNode().val(value);
            }
        }, {
            getBlockName: function () {
                return 'input';
            }
        });

        provide(Input);
});
```

Это всего лишь заготовка. Она мало что умеет делать. Да и выглядит странно: какой-то `module.define()`, какой-то
`provide`. Что это?

Мы пишем клиентский `javascript` в виде модулей. Если сказать по-простому, то мы пишем `javascript`-программу и 
помещаем её в специальный контейнер, который называем модулем.

Модульных систем много разных, Бивис использует
[Ymaps Modules](https://github.com/ymaps/modules/blob/master/what-is-this.md), которые придумали и разработали
разработчики из Яндекс.Карт. Пройдите по ссылке, прочитайте.
В основе модулей лежит очень простая идея, и в документации к `Ymaps Modules` простым языком описывается,
зачем модульная система нужна и как её использовать.

Не стали читать? ;) Там чтения на пять минут. Мы всё таки настаиваем, вам понравится.
[Прочитайте](https://github.com/ymaps/modules/blob/master/what-is-this.md).

Прочитали? Тогда вы понимаете, что код внутри анонимной функции - это и есть код,
который программирует поведение вашего `input`. Можно было бы программировать его по старинке,
навешивая события на DOM-элементы самим или через jQuery-хелперы. Но мы предпочитаем работать с блоками через
абстракции, чтобы не зависеть от HTML-реализации блока.

Поэтому мы в зависимостях модуля `input` указали два других модуля — `inherit` и `block`.
Первый модуль возвращает функцию `inherit`, которая используется для создания классов и наследования (подробное
описание читайте на странице автора:
[https://github.com/dfilatov/node-inherit](https://github.com/dfilatov/node-inherit).

Второй модуль (`block`) - это `javascript`-класс, который реализует механизмы абстрагирования от DOM-узлов. Это 
базовый визуальный блок.

_Все блоки, которые вы создаёте в проекте и которые пользователь может 
увидеть на страницах вашего сайта (мы такие блоки называем визуальными), должны наследоваться от
модуля `block` с помощью модуля `inherit`._

Я употребил слово "наследоваться". Это слово звучит странно применительно к программе на `Javascript`.
Наверное, каждому веб-разработчику известно, что нативного механизма наследования в `Javascript` нет. Но есть
эмуляции, одна из них как раз и есть модуль [inherit](https://github.com/dfilatov/inherit). Документация к этому модулю
написана серьёзно, академически. Здесь же мы попытаемся быстро и по-простому объяснить смысл этого модуля.

Вот вся суть:
```javascript
var B = inherit(A, {});
```

Создаём класс `B`, который наследует методы из класса `A`, и доопределяет своими собственными методами. Эти
дополнительные методы описываются во втором аргументе функции `inherit`. В примере выше никаких методов внутри 
второго параметра не описано, поэтому класс `B` просто отнаследуется от класса `A`.

А уже в этом коде мы с вами создадим класс `Input`, как наследника от класса `Yblock`, и насытим его собственными 
методами `getValue` и `setValue`:

```javascript
var Input = inherit(YBlock, {
    __constructor: function () {
        this.__base.apply(this, arguments);

        console.log(this.getValue());
    },

    getValue: function() {
        return this.getDomNode().val();
    },


    setValue: function(value) {
        this.getDomNode().val(value);
    }
});
```

Метод `__constructor` - особый метод. Если другие методы мы вольны называть как нам нравится, то
именно этот метод должен называться так и никак иначе. Это конструктор класса.

В объектно-ориентированном программировании конструктор класса — это специальная функция, вызываемая при создании
объекта класса. Создадим объект нашего класса `Input`:

```javascript
var myInput = new Input();
```

Когда `javascript`-интерпретатор приступит к выполнению конструкции `new Input()`, он первым делом вызовет функцию
`__constructor`. Можно считать, что это точка входа в вашу программу, описанную в файле `/blocks/input/input.js`

Интерпетатор входит в метод `__constructor` и выполняет всё, что вы там написали.

А написано там пока немного.

Во-первых, инструкция `this.__base.apply(this, arguments);` - её можно не пытаться понять,
просто запомнить и писать в каждом конструкторе каждого вашего блока. 

_Вообще-то это способ из конструктора класса `Input` вызвать конструктор класса `YBlock`._
_То есть, вы описали класс `Input` как наследника от класса `YBlock`. А потом создали экземпляр `myInput`. В тот момент,
когда вы создали объект `myInput`, вызвался его `__constructor`, который вызвал точно такой же `__constructor` 
в `YBlock`._

Если строка `this.__base.apply(this, arguments);` выглядит пугающе, не обращайте внимания, эта строка неинтересная. 
Интересно другое.

С помощью модуля `inherit` мы пишем клиентский `javascript`-код в `ООП`-стиле. Не в виде спагетти-функций, которые друг
друга вызывают в хаотичном порядке, а в виде классов и порожденных ими объектов.




----



# YBlock

Базовый класс для написания блоков, содержит общее для всех блоков поведение:

* Методы установки/получения состояний.
* Методы для размещения блока в нужном фрагменте DOM-дерева.
* Базовый конструктор и деструктор.
* Разбор `js`-параметров из DOM-элементов.
* Интерфейс конструирования блоков с помощью BT-шаблонов.
* Инициализация/деинициализация блоков на переданном фрагменте DOM-дерева.
* Интерфейс для отложенной (`live`) инициализации.
* Статические метод класса

----

как от него отнаследоваться,
как инициализировтаься,
как получить доступ к блоку,
как получить доступ к элементы,
как повесить обработчик события,
как сделать лив-инициализацию

----


