в разработке

----

Мы с вами проделали уже большой путь — [создали новую страницу](new-page.md),
[создали новый блок и написали простые bt-шаблоны](new-block.md),
[написали к блоку стили и расширили bt-шаблоны](css.md).

У нас есть страница `/pages/test-page/test-page.page.js`, а в ней единственный блок `input`:

```javascript
module.exports = function (pages) {
    pages.declare('test-page', function (params) {
        var options = params.options;
        return {
            block: 'page',
            title: 'test page',
            styles: [
                {url: options.assetsPath + '.css'}
            ],
            scripts: [
                {url: options.assetsPath + '.js'}
            ],
            body: [
                {
                    block: 'input',
                    view: 'large',
                    value: 'Привет, Бивис',
                    name: 'loginField',
                    placeholder: 'на сайте'
                }
            ]
        };
    });
}
```

Если проект запустить, то по адресу `http://localhost:8080/test` мы увидим страницу с серым фоном и текстовым полем,
в котором уже введено значение "Привет, Бивис".

Если в браузере заглянуть в `HTML`-код блока, увидим следующую структуру:

```html
<div class="input_large _init" data-block="input">
    <input class="input_large__control" value="Привет, Бивис" name="loginField" placeholder="Инпут на сайте">
    <div class="input_large__clear"></div>
</div>
```

Созданием этого `HTML`-кода занимаются `bt`-шаблоны, которые мы с вами написали в файле `/blocks/input/input.bt.js`.
Стилизацией блока занимается целая система файлов `/blocks/input/input*.styl`.

Самое время запрограммировать поведение блока — cделать блок интерактивным, т.е. отзывчивым на действия пользователя.

Когда мы [создавали новый блок](new-block.md), мы сделали заготовку для клиенсткого программирования. Вот она:

`/blocks/input/input.js`

```javascript
modules.define(
    'input',
    ['inherit', 'block'],
    function (provide, inherit, YBlock) {
        var Input = inherit(YBlock, {
            __constructor: function () {
                this.__base.apply(this, arguments);

                console.log(this.getValue());
            },

            getValue: function() {
                return this.getDomNode().val();
            },


            setValue: function(value) {
                this.getDomNode().val(value);
            }
        }, {
            getBlockName: function () {
                return 'input';
            }
        });

        provide(Input);
});
```

Это всего лишь заготовка. Она мало что умеет делать. Да и выглядит странно: какой-то `module.define()`, какой-то
`provide`. Что это?

Мы пишем клиентский `javascript` в виде модулей. Если сказать по-простому, то мы пишем `javascript`-программу и 
помещаем её в специальный контейнер, который называем модулем.

Модульных систем много разных, Бивис использует
[Ymaps Modules](https://github.com/ymaps/modules/blob/master/what-is-this.md), которые придумали и разработали
разработчики из Яндекс.Карт. Пройдите по ссылке, прочитайте.
В основе модулей лежит очень простая идея, и в документации к `Ymaps Modules` простым языком описывается,
зачем модульная система нужна и как её использовать.

Не стали читать? ;) Там чтения на пять минут. Мы всё таки настаиваем, вам понравится.
[Прочитайте](https://github.com/ymaps/modules/blob/master/what-is-this.md).

Прочитали? Тогда вы понимаете, что код внутри анонимной функции - это и есть код,
который программирует поведение вашего `input`. Можно было бы программировать его по старинке,
навешивая события на DOM-элементы самим или через jQuery-хелперы. Но мы предпочитаем работать с блоками через
абстракции, чтобы не зависеть от HTML-реализации блока.

Поэтому мы в зависимостях модуля `input` указали два других модуля — `inherit` и `block`.
Первый модуль возвращает функцию `inherit`, которая используется для создания классов и наследования (подробное
описание читайте на странице автора:
[https://github.com/dfilatov/node-inherit](https://github.com/dfilatov/node-inherit).

Второй модуль (`block`) - это `javascript`-класс, который реализует механизмы абстрагирования от DOM-узлов. Это 
базовый визуальный блок.

_Все блоки, которые вы создаёте в проекте и которые пользователь может 
увидеть на страницах вашего сайта (мы такие блоки называем визуальными), должны наследоваться от
модуля `block` с помощью модуля `inherit`._

Я употребил слово "наследоваться". Это слово звучит странно применительно к программе на `Javascript`.
Наверное, каждому веб-разработчику известно, что нативного механизма наследования в `Javascript` нет. Но есть
эмуляции, одна из них как раз и есть модуль [inherit](https://github.com/dfilatov/inherit). Документация к этому модулю
написана серьёзно, академически. Здесь же мы попытаемся быстро и по-простому объяснить смысл этого модуля.

Вот вся суть:
```javascript
var B = inherit(A, {});
```

Создаём класс `B`, который наследует методы из класса `A`, и доопределяет своими собственными методами. Эти
дополнительные методы описываются во втором аргументе функции `inherit`. В примере выше никаких методов внутри 
второго параметра не описано, поэтому класс `B` просто отнаследуется от класса `A`.

А уже в этом коде мы с вами создадим класс `Input`, как наследника от класса `Yblock`, и насытим его собственными 
методами `getValue` и `setValue`:

```javascript
var Input = inherit(YBlock, {
    __constructor: function () {
        this.__base.apply(this, arguments);

        console.log(this.getValue());
    },

    getValue: function() {
        return this.getDomNode().val();
    },


    setValue: function(value) {
        this.getDomNode().val(value);
    }
});
```

Метод `__constructor` - особый метод. Если другие методы мы вольны называть как нам нравится, то
именно этот метод должен называться так и никак иначе. Это конструктор класса.

В объектно-ориентированном программировании конструктор класса — это специальная функция, вызываемая при создании
объекта класса. Создадим объект нашего класса `Input`:

```javascript
var myInput = new Input();
```

Когда `javascript`-интерпретатор приступит к выполнению конструкции `new Input()`, он первым делом вызовет функцию
`__constructor`. Можно считать, что это точка входа в вашу программу, описанную в файле `/blocks/input/input.js`

Интерпетатор входит в метод `__constructor` и выполняет всё, что вы там написали.

А написано там пока немного.

Во-первых, инструкция `this.__base.apply(this, arguments);` - её можно не пытаться понять,
просто запомнить и писать в каждом конструкторе каждого вашего блока. 

_Вообще-то это способ из конструктора класса `Input` вызвать конструктор класса `YBlock`._
_То есть, вы описали класс `Input` как наследника от класса `YBlock`. А потом создали экземпляр `myInput`. В тот момент,
когда вы создали объект `myInput`, вызвался его `__constructor`, который вызвал точно такой же `__constructor` 
в `YBlock`._

Если строка `this.__base.apply(this, arguments);` выглядит пугающе, не обращайте внимания, эта строка неинтересная. 
Интересно другое.

С помощью модуля `inherit` мы пишем клиентский `javascript`-код в `ООП`-стиле. Не в виде спагетти-функций, которые друг
друга вызывают в хаотичном порядке, а в виде классов и порожденных ими объектов.

В конструкторе ровно это и происходит - мы вызываем собственный метод `getValue` и результат выводим в консоль браузера:

```javascript
__constructor: function () {
    this.__base.apply(this, arguments);

    console.log(this.getValue());
}
```

Ещё раз о важном. Работа любого модуля начинается с метода `__constructor`. Это точка входа в программу модуля. А уже
 из контруктора мы сами организуем работу модуля как хотим - слушаем события, реагируем на них, может быть, 
 инициализируем какие-то другие модули — что угодно.
   
Например, контрол `input` имеет элемент `clear`, по нажатию на который мы должны очистить поле ввода от введенного 
текста. Алгоритм задачи я бы для себя описал так:

1. Найти элемент, сохранить на него ссылку.
2. Забиндить событие клика на нём и повесить обработчик клика.
3. В обработчике стереть текст из текстового поля.
 
Измените метод `__constructor`, чтобы он выглядел как у меня: 
 
```javascript
__constructor: function () {
    this.__base.apply(this, arguments);

    // 1. Найти элемент, сохранить на него ссылку.
    var clear = this._findElement('clear');
    console.log(clear);
}
```

И тут мы знакомимся с методом `_findElement` — для нас первым методом блока `YBlock` (от которого мы отнаследовали
`Input`). 

Первое, что бросается в глаза — знак нижнего подчеркивания перед именем. Почему `_findElement`, а не `findElement`?
Символ нижнего подчеркивания — это индикатор, что метод приватный... Как бы приватный :) "Как бы", потому что этот  
символ перед именем `javascript`-метода ни на что не влияет. Это в настоящих ООП языках такой метод не может быть  
вызван из другого компонента — сам язык программирования не позволит вам этого сделать технически. Но в `Javascript`  
такой возможности нет, но очень хочется :)
 
 Хочется отделить публичные методы компонента (которые могут быть вызываны из других компонентов) от приватных 
 методов (которые доступны для вызова только изнутри). А раз технической возможности нет, но сильно хочется, то можно 
 договориться между разработчиками и соблюдать устную договорённость. Мы и договорились — если перед именем метода есть 
 символ нижнего подчеркивания, это метод приватный, относись к нему с почтением :)
   
Так как блок `Input` отнаследован от `YBlock`, то метод `_findElement` у инпута есть. Собственно ради этого метода и 
многих других мы от `YBlock` и хотим наследоваться. Увидеть все методы блока `YBlock` вы 
можете [по этой ссылке.](https://github.com/bevis-ui/bevis-stub/blob/master/core/block/block.js)

А сигнатуру метода `_findElement` мы посмотрим прямо здесь:

```javascript
/**
 * Возвращает первый элемент с указанным именем.
 *
 * @protected
 * @param {String} elementName Имя элемента.
 * @param {HTMLElement|jQuery} [parentElement] Элемент в котором необходимо произвести поиск. Если не указан,
 *                                             то используется результат `this.getDomNode()`.
 * @returns {jQuery|undefined}
 *
 * @example
 * var title = this._findElement('title');
 * title.text('Hello World');
 */
_findElement: function (elementName, parentElement) {
    return this._findAllElements(elementName, parentElement)[0];
}
```
Первый парамет метода - строковое имя элемента, который мы ищем. Обязательный параметр.

Второй параметр — необязательный, о чём нам в `JSDoc`-е говорит имя параметра, заключённое в квадратные скобки 
`[parentElement]` — родительский элемент, в котором необходимо произвести поиск. Обратите внимание, что в этот 
параметр нужно передавать не строкое имя элемента (как было в первом параметре), а именно сам элемент в виде 
`HTMLElement` или в виде `jQuery`, о чём нам сообщает тип параметра `@param {HTMLElement|jQuery} [parentElement]`.

Метод возвращает `jQuery`, если такой элемент найден, или `undefined`, если такого элемента не существует: 
`@returns {jQuery|undefined}`

Так как этот метод отнаследован нами из `YBlock`, то и вызываем мы его так, словно это метод блока `Input` - через 
ключевое слово `this`. А если отовинуться от монитора и посмотреть на строчку свежим взглядом, то можно прочитать её,
 как предложение на русском языке. 
```javascript
    var clear = this._findElement('clear');
    // У этого блока найди элемент 'clear' и сохрани его в локальной переменной. 
}
```
Понятно ведь, правда?


Ниже `_findElement` мы добавили вывод в консоль и теперь смотрим, что возвращает метод в нашей программе. 
Обновляем `http://localhost:8080/test` (или открываем, если закрыли) и видим в консоли браузера что-то подобное:

```
{
    0: 'div.input_large__clear',
    context: 'div.input_large__clear',
    length: 1,
    __proto__: x[0]
}
``` 
Это `jQuery`-представление нашего элемента `clear`. Отлично, значит элемент нашли и сохранили в локальную переменную 
внутри метода `__constructor`.

Двигаемся дальше, и будем слушать событие `click` на крестике:
 
```javascript
__constructor: function () {
    this.__base.apply(this, arguments);

    // 1. Найти элемент, сохранить на него ссылку.
    var clear = this._findElement('clear');
    
    // 2. Забиндить событие клика на нём и повесить обработчик клика.
    this._bindTo(clear, 'click', function () {
        console.log('Крестик нажат');
    });
}
```

Знакомимся со следующим методом — `_bindTo`. Сигнатуру его тоже посмотрим здесь:
```javascript
/**
 * Добавляет обработчик события `event` объекта `emitter`. Контекстом обработчика
 * является экземпляр данного блока. Обработчик события автоматически удалится при вызове
 * `Block.prototype.destruct()`.
 *
 * @protected
 * @param {jQuery|Block} emitter
 * @param {String} event
 * @param {Function} callback
 * @returns {Block}
 *
 * @example
 * var View = inherit(Block, {
 *     __constructor: function (model) {
 *         this.__base();
 *
 *         var hide = this._findElement('hide');
 *         this._bindTo(hide, 'click', this._onHideClick);
 *
 *         this._bindTo(model, 'change-attr', this._onAttrChange);
 *     }
 * });
 */
_bindTo: function (emitter, event, callback) {
    this._eventManager.bindTo(emitter, event, callback);
    return this;
}
```
Первый параметр — элемент или блок, на котором слушаем событие
Второй параметр — строковое имя события
Третий — функция-обработчик события. Вызовется, когда событие случится.

Тоже приватный метод. И тоже читается, как предложение на русском языке.

```javascript
    this._bindTo(clear, 'click', function () {
        console.log('Крестик нажат');
    });
    // У этого блока привяжи элемент clear к событию 'click', и когда оно случится, вызови функцию-обработчик.
}

Обновите страницу в браузере и нажмите мышкой на крестик. В консоли видим сообщение: "Крестик нажат"? Прекрасно.

В `JSDoc` метода `_bindTo` есть примеры его вызова. Видно, что третьим параметром функцию-обработчик мы там не 
описываем, а только указываем её имя. Сделаем так у себя:
1. Отредактируйте третий параметр в методе `_bindTo`
2. Ниже конструктора добавьте метод `_onClearClicked` и напиши в нём какой-то новый `console.log`, чтобы убедиться, 
что изменения вступили в силу: 

Было:
```javascript
__constructor: function () {
    this.__base.apply(this, arguments);

    // 1. Найти элемент, сохранить на него ссылку.
    var clear = this._findElement('clear');
    
    // 2. Забиндить событие клика на нём и повесить обработчик клика.
    this._bindTo(clear, 'click', function () {
        console.log('Крестик нажат');
    });
}
```

Стало:

```javascript
__constructor: function () {
    this.__base.apply(this, arguments);

    // 1. Найти элемент, сохранить на него ссылку.
    var clear = this._findElement('clear');

    // 2. Забиндить событие клика на нём и повесить обработчик клика.
    this._bindTo(clear, 'click', this._onClearClicked);
},

_onClearClicked: function () {
    console.log('_onClearClicked: Крестик нажат');
},
```

Проверям, в консоли видим сообщение: "_onClearClicked: Крестик нажат". Успех.

Мы только что создали собственный приватный метод блока `Input`. Именно в нём мы будем очищать текстовое поле ввода. 
Напишем для метода `JSDoc`:
 

----



# YBlock

Базовый класс для написания блоков, содержит общее для всех блоков поведение:

* Методы установки/получения состояний.
* Методы для размещения блока в нужном фрагменте DOM-дерева.
* Базовый конструктор и деструктор.
* Разбор `js`-параметров из DOM-элементов.
* Интерфейс конструирования блоков с помощью BT-шаблонов.
* Инициализация/деинициализация блоков на переданном фрагменте DOM-дерева.
* Интерфейс для отложенной (`live`) инициализации.
* Статические метод класса

----

как от него отнаследоваться,
как инициализировтаься,
как получить доступ к блоку,
как получить доступ к элементы,
как повесить обработчик события,
как сделать лив-инициализацию

----


