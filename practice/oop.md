# ООП. Объектно-ориентированное программирование

`ООП` - это не что-то магическое и доступное только гениям программирования. Даже школьник, не вылезающий по 
информатике из троек, способен понять, что такое `ООП`, потому что объектно-ориентированное программирование — это лишь
 _ещё один_ способ организации своего кода. 

_`ООП` - это когда вы пишете свой `Javascript`-код не в виде плоского списка функций, а в виде так называемых
`Классов` и `Объектов`. Всё!_

Непонятно? Вот и мне было непонятно, когда я знакомился с этой темой впервые :)

В классических учебниках эту тему традиционно пытаются объяснять на примере объектов живого мира.

----

"Давайте выйдем на улицу и оглядимся", — предлагают нам авторы учебников. — "Что мы увидим? Припаркованные у 
тротуаров машины, спешащих по тротуарам людей. В небе самолёт увидим, — белый след за собой оставляет. Обычная картина."
 
На что мы с вами смотрели? Да на объекты и смотрели — на объекты разных типов. Машины - это объекты одного типа. Люди - 
объекты другого типа. Самолёты - третьего. То, что мы в жизни называем словом "тип", в `ООП` именуют словом `Класс`.   

Каждый из этих ~~типов~~ классов имеет общие характерные признаки. К примеру, машина имеет 4 колеса, двигатель, руль, 
 и умеет передвигаться в пространстве. И там, в учебниках, утверждается, мол, **все** автомобили имеют **все эти** 
 характерные признаки, а, к примеру, лифты имеют **не все эти** признаки, зато имеют какие-то свои 
 особенные признаки, следовательно они принадлежат к другому `Классу Объектов`.

А `Объект` — это, мол, не абстрактный автомобиль, а вполне себе конкретная машина, созданная на конкретном 
автомобильном заводе. Машина имеет все характерные признаки класса автомобиль (4 колеса, двигатель, руль...), но это уже не 
абстрактный класс (не абстрактный тип автомобиля), а вполне себе реальная штуковина, которую можно пощупать, в неё 
можно сесть, завести и поехать на море.

То есть, `Класс`, — объясняли в учебнике, - это `сущность абстрактная, шаблонная`. Такая же, как лекало, образец. Она 
лишь описывает свойства и умения, которыми будет обладать конкретный объект, когда его создадут по этим правилам. А 
`Объект - это уже конкретная реализация этого класса`.

----

Я когда читал эти объяснения в учебнике, я всё понимал. Про автомобили, лифты, самолёты - всё понимал. Про `ООП` в 
`Javascript` - ничего не понимал. Как знания про автомобили применить к моим программам? Вообще непонятно.

Попыток объяснить эту тему существует множество — их легко найти в учебниках про настоящие объектно-ориентированные
языки, среди которых на слуху `Java` и `C#`. Сейчас эти попытки можно обнаружить и в учебниках про `Javascript`. Но
я всё же собираюсь предпринять свою собственную, потому что меня не устраивают объяснения всех этих бесспорно
уважаемых людей. Я вам объясню эту тему так, как собираюсь объяснять её своей дочери годика эдак через четыре (сейчас
 ей десять). То есть, понятно. И не про автомобили и лифты, а именно про `Javascript`.

## Что нужно знать?

К тому моменту, когда дочь будет готова воспринимать эту тему, она должна будет понимать, что такое переменные, какие типы переменных существуют в `Javascript`, какие методы существуют у встроенных типов (например, у строк, у чисел, у массивов). Дочь должна уметь создавать функции, уметь их вызывать и принимать от них результаты.

Если всей этой базы не понимать, задаваться вопросом, что такое объектно-ориентированное программирование, совершенно незачем. ООП - это абстракция над базовыми возможностями `Javascript`. Если не знать базовых возможностей, глупо лезть в дебри.

Я предполагаю, что вы прекрасно разбираетесь в основах. Поэтому вперёд.

## Вообще-то, вы умеете писать объектно-оринтированный код!

Конечно же! Не ослышались. И хотя даже школьник-троеничник знает, что `Javascript` вообще ни разу не
объектно-ориентированный язык, вам следует знать, что когда вы пишете `Javascript`-программу, вы чуть ли не в
каждой строчке своего кода создаёте `Объекты` из `Классов` и оперируете ими мастерски, только не осознаёте этого.

Каждый из нас _уже умеет_ писать объектно-ориентированные программы.

```javascript
var data = [];
```
Что в этом коде происходит? Ничего  магического, скажете вы. Ну, создаём переменную `data` и присваиваем ей значение
 пустой массив. Вам этот оператор  совершенно понятен. Ну, переменная. Ну, массив. Ну и?

На самом деле, этот же оператор может быть записан иначе. Вы это наверняка знаете. Или знали раньше, но забыли:
```javascript
var data = new Array();
```
Этот код совершенно идентичен предыдущему. Но я попробую предположить, что разработчики `Javascript` пожалели нас,
бедных, и дали нам возможность писать это же короче - без вызова оператора `new` и без указания типа `Array`.
Спасибо им. Но что такое `new Array()`? Посмотрим на два фрагмента кода и сравним комментарии к ним:

```javascript
// Создаём переменную `data` типа "массив"
var data = [];
```

```javascript
// Создаём объект `data` класса "массив"
var data = new Array();
```

То есть вместо слова `переменная` можно смело говорить слово `объект`. А вместо слова `тип` можно смело говорить
слово `класс`.

Вы так не говорили никогда, я тоже так никогда не говорил — так говорить нас не учили ни в одном учебнике. Но если мы
  хотим научиться писать объектно-ориентированные программы, нужно нуачиться смотреть на свои уже написанные программы
  под новым углом. Мне кажется, если вы представите, что любая переменная, которую вы создавали в своей жизни, на самом
  деле никакая не переменная, а `Объект` какого-то `Класса`, понять всё остальное про `ООП` будет легко. Попробуйте
  вместе со мной относиться к переменным именно так. Договорились, пробуем?

Когда вы создаёте переменную типа `Array`, на самом деле вы создаёте объект класса `Array`. Или "экземпляр класса
`Array`". Замысловато звучит, чужеродно даже. Но так принято, все `ООП`-адепты выражаются именно такими словами и друг 
 друга понимают. И мы привыкнем, и мы научимся.

Повторяем и запоминаем. Когда мы пишем `var data = []`, на самом деле мы создаём не просто переменную с типом 
`Array`, а экземпляр класса `Array`. Или, если другими словами, — объект класса `Array`.

Как любая реальная машина имеет 4 колеса, двигатель и салон, так и любой объект, созданный из класса `Array` имеет
свой характерный набор признаков. Это же понятно, да?

```javascript
var data = new Array();
console.log(data.length); // --> 0
```

Мы только что создали объект `data`, и у него вдруг появляется свойство `length`, хотя мы такое свойство не определяли. 
Оно появилось само собой. Откуда? Вы прекрасно знаете, что любой массив обладает таким свойством, подумаешь, — эка 
невидаль. Но давайте отнесёмся к этой ситуации по-новому. 

Покатайте в уме такое объяснение: любой экземпляр класса `Array` обладает свойством `length`. Как только мы создали 
новый экземпляр класса с помощью оператора `var data = new Array()` (или с помощью шотката `var data = []`, что одно
 и то же ) и сохранили его в объекте `data`, созданный объект сразу приобрел сразу все характерные признаки класса 
 `Array`.

 У любого массива есть такое свойство, как длина (в смысле, количество элементов массива). Это признак массива? 
 Признак, конечно. А есть ли такой признак у числа? Правильнее было бы задать этот вопрос другими словами: "А есть 
 ли точно такой же признак у объекта, созданного от класса `Number`"? Нет.

 Доказываю. Создаём объект класса `Number` и спрашиваем у него длину:
```javascript
var age = new Number(36);
console.log(age.length); // undefined
```
Нет такого свойства у экземпляра класса `Number`. Да вы и сами это знаете, только никогда не рассуждали об этом 
словами `Класс` и `Объект`.

Вот и получается, что объект класса `Array` будет обладать своим набором каких-то свойств и умений. А объект типа 
`Number` будет обладать своим набором свойств и умений. И наборы эти разные. Когда мы создаем экземпляр класса, 
экземпляр автоматически приобретает свойства и умения, характерные для всех объектов этого класса. Все машины имеют по 4
 колеса и умеют двигаться по дорогам, а все самолёты имеют по 3 колеса и умеют летать по небу.

Но это всё бытовые примеры. Они хороши и занимательны, только очень уж далеки от `Javascript`. 

Если вы когда нибудь генерировали картинки на лету и вставляли в `DOM`, то наверняка делали это так:
```javascript
var logo = new Image();
logo.src = "http://lorempixel.com/output/cats-q-c-427-203-3.jpg";
logo.alt = "Sadness";
logo.title = "Изготовление сайтов под ключ";
document.body.appendChild(logo);
```

Этих 4-х строк достаточно, чтобы в теге `body` появился новый тег
```html
<img src="http://lorempixel.com/output/cats-q-c-427-203-3.jpg" alt="Sadness" title="Изготовление сайтов под ключ">
```
А если над картинкой задержать мышку, браузер ещё покажет тултип с текстом "Изготовление сайтов под ключ". 

Для вас это, наверняка, никакая ни новость. Но задумайтесь — мы написали один простой оператор `new Image()` и получили 
объект, который обладает сразу и  `HTML`-разметкой, и `CSS`-стилями и интерактивным поведением. Получается, что в 
браузер встроен класс объектов `Image`. А когда написали оператор `new Image()`, мы создали экземпляр класса 
`Image`, и он сразу, — мгновенно, — получил все свойства картинки.

_Кстати, экземпляр класса ещё называют инстансом класса от англ. ["instance"](https://translate.yandex.ru/?text=%D1%8D%D0%BA%D0%B7%D0%B5%D0%BC%D0%BF%D0%BB%D1%8F%D1%80&lang=ru-en)._
                                                
Это и называется `Объектно-Ориентированное Программирование`.

Ах, как жаль, что таких встроенных в браузер классов очень мало. Почему нет класса `Input`, `Button`, `Form`? Как 
было бы легко программировать веб-сайты, если бы таких классов было много и сразу. Но их нет. Это минус. Зато их 
можно создавать самим, и это плюс. Цель этого туториала — показать вам, что создавать свои собственные классы - это 
очень просто. Программировать в `ООП`-стиле на `Javascript` - это просто и удобно.

Попробовав это один раз, вы влюбитесь в `ООП`-стиль и будете удивляться, как же вы программировали раньше без `ООП`?

Подводём быстрые итоги.

В `Javascript` мы всё время оперируем не просто переменными (как мы всегда думали), а исключительно конкретными 
инстансами классов. Создаём ли мы строковую переменную или чисельную, или логическую, или массив, или функцию(!) — 
на самом деле мы создаём экземпляры соответствующих классов `String`, `Number`, `Boolean`, `Array` или `Function`. 

Вы делали это в каждой программе. 

Вы умеете это делать в совершенстве.

Только раньше вы использовали _уже существующие_ в `Javascript` классы. А теперь нам хочется уметь создавать _свои 
собственные_ классы, чтобы сделать код ещё более удобным.

## Как мы программируем по-старинке

Начинающие веб-программисты думают про `web`-страницы, как про набор `HTML`-тегов. Например, элементы формы
"текстовое поле" - это тег `<input type="text">`. Как на странице может появиться такой тег?

1. Сервер может построить `HTML` страницы и отдать в браузер. И в этой `HTML`-ке где-то внутри `body` уже будет такой
тег.
2. Мы можем на стороне браузера сгенерить такой тег в клиентском `js`.

Серверную генерацию рассматривать не будем, это скучно. Хочется веселья. Как мы можем сгенерить инпут налету?
```javascript
var myInput = document.createElement('input');
myInput.type = 'text';
document.body.appendChild(myInput);
```

Или можно с помощью jQuery:
```javascript
var myInput = $('<input type="text">');
myInput.appendTo('body');
```

В обоих случаях внутри тега `body` появится новый тег `input`.

Нам хочется, чтобы этот инпут взаимодействовал с пользователем.  Например:

1. Если пользователь поставил курсор в поле, обвести поле фокусной рамкой нужного цвета.

2. Если поле находится в фокусе, и пользователь ввел какой-то текст в поле, а затем нажал кнопку `ESC`, очистить поле от введенного значения.

3. Если поле находится в фокусе, и пользователь нажал кнопку `Enter`, отправить данные из поля на сервер. 

Такого поведения браузер не обеспечил для вновь созданного инпута. Значит это должны сделать мы. Предположим, что вы
 не используете `jQuery`, а предпочитаете программировать на кристалльно-чистом и бесконечно-прекрасном `Javascript`
 без всяких сторонних библиотек. Тогда ваш код будет выглядеть приблизительно так:

```javascript
var myInput = document.createElement('input');
myInput.type = 'text';

document.body.appendChild(myInput);

// Подписываемся на событие `focus` на инпуте
// Когда на элементе сработает фокус, вызови наш собственный обработчик.
myInput.addEventListener('focus', onInputFocused);

// Подписываемся на событие `keyup` на инпуте
myInput.addEventListener('keyup', onInputKeyUpped);

// Описываем обработчик фокуса
function onInputFocused (e) {
    e.target.style.border = '1px solid yellow';
}

// Описываем обработчик нажатия на клавиши клавиатуры
function onInputKeyUpped (e) {
    if (e.keyCode === 13) {
        console.log(e.target.value);
    } else if (e.keyCode === 27) {
        e.target.value = '';
    }
}
```
Я не стал писать код, отправляющий данные на сервер, для нашей темы это сейчас не важно, — будем выливать значение поля
 в консоль браузера, этого достаточно. В общем виде мы реалиовали задумку. Скорее всего, код можно оптимизировать, —
  я не сомневаюсь, вы можете написать его лучше... Но я не об этом. 
  
Давайте подумаем, где этот код мы пишем? Я предполагаю, что у вас есть какой-то `page.js` файл, в
котором вы пишете всю программу. Этот `page.js` подключается на веб-страницу с помощью тега `<script src='page
.js'></script>`. И вы представляете себе очень хорошо, что когда этот файл загрузится в память браузера, запустится
интерпретатор языка `Javascript`, который будет читать каждую строку в вашем файле `page.js` сверху вниз и выполнять
 одну за другой. По-строчно, одну за одной.  В какой-то момент интерпретатор дойдёт до строк, где мы создаём инпут и
  навешиваем на него обработчики событий. Выполнит операторы в этих строках и пойдёт дальше. С этим проблем нет. Это
   вы понимаете. А что тут не понять, спросите вы?

У меня один вопрос. А если мы создаём не один инпут? Если мы должны создать два, три, четыре инпута.
```html
<input type="text" name="login">
<input type="text" name="email">
<input type="text" name="age">
```

На что станет похож наш код? А я вам покажу:

```javascript
// Создаём три инпута
var inputLogin = document.createElement('input');
inputLogin.type = 'text';
inputLogin.name = 'login';

var inputEmail = document.createElement('input');
inputEmail.type = 'text';
inputEmail.name = 'email';

var inputAge = document.createElement('input');
inputAge.type = 'text';
inputAge.name = 'age';

// Добавляем их в DOM
document.body.appendChild(inputLogin);
document.body.appendChild(inputEmail);
document.body.appendChild(inputAge);

// Слушаем событие focus на каждом инпуте
inputLogin.addEventListener('focus', onInputKeyUpped);
inputEmail.addEventListener('focus', onInputKeyUpped);
inputAge.addEventListener('focus', onInputKeyUpped);

// Слушаем событие keyup на каждом инпуте
inputLogin.addEventListener('keyup', onInputKeyUpped);
inputEmail.addEventListener('keyup', onInputKeyUpped);
inputAge.addEventListener('keyup', onInputKeyUpped);

// Описываем обработчик фокуса
function onInputFocused (e) {
    e.target.style.border = '1px solid yellow';
}

// Описываем обработчик нажатия на клавиши клавиатуры
function onInputKeyUpped (e) {
    if (e.keyCode === 13) {

        // Нажали Enter
        console.log(e.target.value);

    } else if (e.keyCode === 27) {

      // Нажали ESC
      e.target.value = '';

    }
}
```

Конечно, и этот код можно оптимизировать, с помощью нескольких `forEach`, например. Но даже так он останется
некрасивым. Избыточным. А если нам не только инпуты создать надо, а ещё форму. А ещё шапку сайта. Или подвал. Или
вообще все-все элементы на странице нам надо создавать налету? Создавая код по старинке, мы получим огромную
простынь операторов. Интерпретатор `Javascript` жаловаться не будет, ему всё равно - он все прочитает и выполнит. Но
 ведь нам, людям, такой код читать и поддерживать трудно. Больно.

_Конечно, можно этот код разносить по нескольким файлам, а потом склеивать их в один `page.js` с помощью какого-то 
сборщика вроде `Grunt`, `Gulp` и т.п. Я вам так скажу - не только можно, а нужно. Необходимо! Этим вы хотя бы немного
 облегчите себе работу с этим кодом. Но просто разносить такой код по отдельным файлам мало помогает. Если 
 потребуется добавить новую функциональность, то придется делать это сразу в трех файлах, про два из которых вы 
 вспомните, а третий останется непоправленным. Хаос, тьма, потеря-потерь._

Вот, если бы (давайте помечтаем вслух) в браузере уже существовал специальный класс `Input`? А в нём были бы описаны
 все нужные обработчики событий? Как бы мы тогда создали три инпута?

Наверное так:
```javascript
//  Создаём три инпута
var inputLogin = new Input({name: 'login'});
var inputEmail = new Input({name: 'email'});
var inputAge = new Input({name: 'age'});

// Добавляем в DOM
document.body.appendChild(inputLogin);
document.body.appendChild(inputEmail);
document.body.appendChild(inputAge);
```

Вставка в DOM никуда бы не делась. А вот описывать обработчики для каждого инпута нам  уже не нужно. _Было бы_ не нужно. Красота.

К счастью, мы можем такую красоту сделать сами.

## Создаём объекты из классов — оператор `new`

Об операторе `new` можно почитать в учебнике Ильи Кантора: [https://learn.javascript.ru/constructor-new](https://learn.javascript.ru/constructor-new). Прочитайте обязательно.

Но даже если не прочитали, вы уже поняли, что оператор `new` нужен для того, чтобы создать инстанс какого-то класса, — 
 экземпляр, конкретный объект. Что происходит под капотом этого оператора, прямо сейчас совершенно не важно знать. 
 Важно понять одно - для создания инстансов класса в языке `Javascript` всё есть.

Чего в нём нет, так это _красивого_ способа описывать свои собственные Классы. Слово "красивого" я выделил курсивом 
не случайно. Нет именно красивого способа. А вообще-то такой способ есть. Он странный и чужеродный для понимания 
человеком, но он есть. И мы сейчас его изучим.

Раз уж браузер не обеспечил нас, разработчиков, классом `Input`, напишем его сами.

Напомню, создавать инстанс этого класса мы хотим так:
```javascript
var inputLogin = new Input({name: 'login'});
```

## Создаём свой Класс

Вам известно, с помощью чего в `Javascript` создаются функции? Конечно, вы пишете не меньше десятка таких функций в 
день:
```javascript
function getValue () {
    // ...  
}
```

А теперь взгляните, с помощью чего в `Javascript` создаются ` Классы`:
```javascript
function Input () {
    // ...
}
```

Забавно? Классы мы создаём тоже с помощью функций. То есть вы _уже умеете_ создавать классы в `Javascript` ;)

_Обратите внимание, имя класса начинается c заглавной — `Input`. "Классы именуем с заглавной", — это неписаное 
соглашение среди ООП-программистов. Его можно игнорировать, но лучше ему следовать, чтобы вы сами могли отличить 
по именам, где plain-функция, а где целый класс._

Теперь внимание, ответственный момент. Мы создаём первый в нашей жизни `Javascript-класс` собственноручно:
```javascript
function Input (params) {
    this.name = params.name;
}

var inputLogin = new Input({name: 'login'});
console.log(inputLogin.name); // --> login
```

Что произошло?

Я описал класс `Input` с помощью функции, а потом создал объект из этого класса (создал инстанс, ещё говорят, 
инстанцию класса). То есть я создал конкретный инпут. 

Этот инпут пока ничего не умеет - ни `HTML` для себя создавать, ни реагировать на действия пользователя — ничего. Он
 умеет лишь хранить в себе поле `name` и заполнять его данными, которые передали при инстанцировании класса `Input`.

Мудрено? :)

Давайте вернёмся с вами к классическому примеру с машинами. Самое время :)

Существует набор правил, по которым создают автомобили. Эти правила гласят, что у любого автомобиля есть набор неких
 свойств и неких умений.

Например, любой автомобиль должен иметь 4 колеса (обычно, у машин всё таки 4 колеса, хотя были попытки сделать и 
трёхколесные). У автомобиля должен быть двигатель. Руль. Двери. Салон для пассажиров. С точки зрения ООП эти 
свойства называются `полями` автомобиля.

Ещё автомобиль должен уметь двигаться. Должен уметь останавливаться. Двери должны уметь открываться и закрываться, 
чтобы в салон могли сесть пассажиры. С точки зрения ООП эти все умения, все действия, называются `методами` автомобиля.

_То есть свойства объекта мы в ООП называем "полями", а действия объекта называем "методами". Почему такие названия, 
сейчас не важно. Просто  запомните: когда встретите слова "поле объекта" или "поле класса", вспоминайте свойства 
автомобиля. А когда встретите "метод объекта" или "метод класса", вспоминайте, что автомобиль умеет делать._

Вернемся к нашему классу `Input` и созданному из него объекту `inputLogin`.
```javascript
function Input (params) {
    this.name = params.name;
}

var inputLogin = new Input({name: 'login'});
console.log(inputLogin.name); // --> login
```

Как мы говорили, объект `inputLogin` ничего не умеет - у него нет никаких умений, нет никаких методов. Но у него 
есть своё собственное свойство, которое хранится в поле `name` и которое можно получить через конструкцию 
`inputLogin.name`. Откуда оно взялось?

Поле `name` описано в классе `Input`. Благодаря оператору `new Input` мы создали экземпляр класса, 
который автоматически приобрёл все свойства класса `Input`. У класса `Input` есть пока только одно единственное 
свойство, описанное в поле `this.name`. Значит и у объекта `inputLogin` будет только оно одно. Но будет совершенно точно.

Вам это ничего не напоминает? В самом начале мы рассматривали пример с инстансом массива. И мы говорили, 
что `var data = []` — это то же самое, что `var data = new Array()`. Следовательно в переменной `data` будет 
существовать инстанс класса `Array`, который сразу приобретает все свойства массивов, одним из которых является 
свойство `length`:
```javascript
var data = new Array();
console.log(data.length); // --> 0
```
Помните?

Так здесь тоже самое, только с другим свойством:
```javascript
function Input (params) {
    this.name = params.name;
}

var inputLogin = new Input({name: 'login'});
console.log(inputLogin.name); // --> login
```

Мне нравится думать, что встроенный в `Javascript` класс `Array` (да и все остальные) тоже описывается с помощью 
`function`, типа так:
```javascript
function Array () {
    this.length = // здесь каким-то образом высчитывается длина строки;
}
```

_Я думаю, это не так. Кажется, там всё написано на `C++`, но мне **удобно так думать** — так мне понятнее._

Да, кстати, пора выучить новый ООП-термин. Функция, с помощью которой мы описывали  класс `Input` ещё называется
функция-конструктор. Или просто конструктор. Потому что она как бы конструирует конкретные инстансы (в нашем случае -
 конкретный объект `inputLogin`). Этот термин нужно выучить, пользоваться им вы будете часто — даже если не в этой
 статье, то в жизни. Все ООП-адепты употребляют его часто.

Итак, мы описали класс, создали от него объект, но добавить этот объект в дерево веб-страницы пока не можем. Потому что объект не представлен никаким тегом. Давайте сделаем наш класс полезным, чтобы он делал то же самое, что раньше мы делали в простыне функций.

```javascript
function Input (params) {
    this.domElement = document.createElement('input');
    this.domElement.name = params.nameAttr;
}

var inputLogin = new Input({nameAttr: 'login'});
document.body.appendChild(inputLogin.domElement);
```

Разберем этот код.

- Я вызвал конструктор класса `Input` с помощью оператора `new Input({nameAttr: 'login'})`.
- Конструктор - это обычная `js`-функция, которая умеет принимать параметры. Ну, я туда и передал параметр в виде хеша `{nameAttr: 'login'}`
- Внутри конструктора я создал новое поле класса `this.domElement` и в него сохранил результат выполнения встроенного в `document` метода `createElement`. Останавливаться на этом методе не надо, верно? Вы и так про него знаете?
- Метод `createElement` возвращает объект класса `HTMLElement`. О, да, это ещё один встроенный в браузер Класс.
- Полученный объект класса `HTMLElement` мы сохраняем в поле `this.domElement` класса `Input`.
- А следующей строкой устанавливаем ему свойство `this.domElement.name`. Оказывается, у объектов класса 
`HTMLElement` есть своё собственное поле `name`, в которое мы можем передать значение. Этим и занимаемся - принимаем
 значение из параметра `params` функции-конструктора (нам приходит хеш с одним ключом `nameAttr`).

_Получается, что в переменной `inputLogin` хранится инстанс класса `Input`. А у этого инстанса есть только одно
собственное поле - `domElement`, которое хранит в себе инстанс класса `HTMLElement`. А у этого инстанса мы поменяли его собственное поле `name` в значение 'login'._

- И потом мы делаем `appendChild` — внутрь `document.body` "зааппендим" фактически инстанс класса `HTMLElement`.
Браузер знает про класс `HTMLElement` всё, и умеет его рендерить в `HTML`-тег.  

В результате внутри тега `body` возникает тег `<input name="login">`.

Почему же я выше говорил, что не существует _красивого_ способа описывать свои собственные классы в `Javascript`?
Почему я так сказал? Вот смотрим мы с вами на функцию-конструктор и всё нам нравится - ладненькая такая функция,
аккуратненькая, понятная. Что не так?

```javascript
function Input (params) {
    this.domElement = document.createElement('input');
    this.domElement.name = params.nameAttr;
}

var inputLogin = new Input({nameAttr: 'login'});
```

Я подразумевал тот факт, что не существует красивого **нативного** способа описывать _методы класса_. 

До сих пор мы описывали свойства объектов, то есть поля. А как запрограммировать поведение?

Машина должна уметь двигаться и останавливаться, а инпут должен уметь реагировать на установку фокуса и нажатие двух 
клавиш на клавиатуре. Как реализовать это поведение внутри класса `Input`? И что важно, как реализовать это внутри 
класса `Input` **нативным** для `Javascript` образом?

Ответ, который пугает каждого неопытного `js`-программиста, звучит сурово: "Через прототипы".

### Методы класса. Prototype

Это суровый ответ, потому что понять, что такое прототипы непросто. Это настолько чужеродное для человеческой культуры изобретение, что понять его смысл получается далеко не сразу. И далеко не у всех из нас. К примеру, я совсем недавно понял эти ужасные прототипы, когда моя коллега из Яндекс.Карт приготовила внутренний семинар на тему "Прототипы в Javascript". Она сделала это специально, чтобы рассказать о прототипах так просто, чтобы понял даже школьник. Школьников на её семинаре не было, а я был. И я понял. Спасибо тебе, Олеся!

И сейчас я вам расскажу очень понятно. Слушайте внимательно.

**Прототипы в Javascript - это... вообще не важно что**. Вообще! Вам не нужно задумываться, что это такое и как они устроены.

_Если очень-преочень интересно, Илья Кантор смог это объяснить [хорошо](https://learn.javascript.ru/prototype).  Но
лучше не надо, поберегите себя. Хотя бы сейчас. Прочитайте через пару недель. Или через пару-тройку месяцев._

Чтобы пользоваться прототипами совершенно не нужно понимать, что это такое. Я, к примеру, не разбираюсь в устройстве своего автомобиля. Но езжу на нём каждый день. И с прототипами можно поступить так же.

Прототипы вы будете использовать для двух вещей:

1. Чтобы описывать методы ваших Классов.

2. Чтобы наследовать один ваш Класс от другого вашего Класса.

Всё!

Как и почему это работает, — пожалуйста, – не задумывайтесь сейчас. Оно вам точно не надо. Пока не надо.

Созадим-ка лучше метод у класса `Input`:

```javascript
function Input (params) {
    this.domElement = document.createElement('input');
    this.domElement.name = params.nameAttr;
}

Input.prototype.onFocused = function (e) {
    e.target.style.border = '1px solid yellow';
};
```

Чтобы в класс добавить метод, его нужно объявить не у самого класса, а у какого-то его служебного поля по имени
`prototype`. Это самый правильный нативный способ добавлять методы в класс.

Почему это способ я называю некрасивым? Потому что хочется обходиться без всяких прототипов. Знаете, как хочется? К примеру очень хочется так:
```javascript
function Input (params) {
    this.domElement = document.createElement('input');
    this.domElement.name = params.nameAttr;

    this.onFocused = function (e) {
         e.target.style.border = '1px solid yellow';
    };
}
```

И знаете, что? Так тоже можно. И это даже называют функциональным стилем программирования `Javascript`-классов. Но я
не рекомендую им пользоваться. Давным-давно, когда я только учился `ООП` на `Javascript`, я создавал классы таким
образом и... мучался с ними. И вы намучаетесь, если будете описывать классы таким образом.

_Дело в том, что такой стиль рождает дополнительные трудности, которые приходится решать ещё более некрасивыми способами: всякими `call(this)` при каждом вызове методов класса или `bind(this)` для каждого описания метода класса . Об этом хорошо рассказал Илья в статье про [функциональное наследование](https://learn.javascript.ru/functional-inheritance), спасибо ему. Прочтите обязательно, только не сейчас. Потом можно ещё прочитать [сравнение функционального и прототипного способов](https://learn.javascript.ru/classes#сравнение), для полноты картины, так сказать._

Сейчас просто поверьте. Прототипный лучше :)

Итак, допилим наш класс, чтобы метод класса работал:
```javascript
function Input (params) {
    this.domElement = document.createElement('input');
    this.domElement.name = params.nameAttr;

    // Подписываемся на событие `focus` на инпуте
    // Когда на элементе сработает фокус, вызови наш собственный обработчик.
    this.domElement.addEventListener('focus', this.onFocused);
}

Input.prototype.onFocused = function (e) {
    e.target.style.border = '1px solid yellow';
};

var inputLogin = new Input({nameAttr: 'login'});
document.body.appendChild(inputLogin.domElement);
```

Если этот код проверить в браузере, внутри тега `body` появится тег `input`. Мы его увидим в окне браузера. А если ткнём мышкой в этот инпут, то браузер создаст на инпуте событие `focus`. А так как мы в конструкторе класса подписались слушать событие `focus` на инпуте, то вызовется собственный метод `this.onFocused`, который мы описали через `Input.prototype.onFocused`.

Добавим ещё один обработчик - будем слушать `keyup` на инпуте. И можно добавить метод, с помощью которого инстанс 
класса будет сам себя рендерить внутри какого-то `HTML`-элемента, в нашем примере внутри `document.body`. И тогда 
нам не придётся каждый инстанс добавлять в дерево — он будет это делать сам из своего конструктора.

```javascript
function Input (params) {
    this.domElement = document.createElement('input');
    this.domElement.name = params.nameAttr;

    // Подписываемся на событие `focus` на инпуте
    // Когда на элементе сработает фокус, вызови наш собственный обработчик.
    this.domElement.addEventListener('focus', this.onFocused);

    // Подписываемся на событие `keyup` на инпуте
    // Когда пользователь нажмёт клавишу на клавиатуре, стоя курсором внутри инпута, вызови наш собственный обработчик.
    this.domElement.addEventListener('keyup', this.onKeyUpped);

    // Рендерим инпут на странице
    this.render();
}

Input.prototype.onKeyUpped = function (e) {
    if (e.keyCode === 13) {
        // Нажали Enter
        console.log(e.target.value);
    } else if (e.keyCode === 27) {
        // Нажали ESC
        e.target.value = '';
    }
};

Input.prototype.onFocused = function (e) {
    e.target.style.border = '1px solid yellow';
};

Input.prototype.render = function () {
    document.body.appendChild(this.domElement);
};

var inputLogin = new Input({nameAttr: 'login'});
```

Всё. Теперь вы знаете всё, чтобы самому описывать собственные классы и создавать от них объекты.

Посмотрим и сравним оба стиля программирования в одной таблице:

<table>
<tr>
    <th>Процедурный стиль</th>
    <th>Объектно-ориентированный стиль</th>
</tr>
<tr>
   <td valign=top>
<pre>
var inputLogin = document.createElement('input');
inputLogin.type = 'text';
inputLogin.name = 'login';

var inputEmail = document.createElement('input');
inputEmail.type = 'text';
inputEmail.name = 'email';

var inputAge = document.createElement('input');
inputAge.type = 'text';
inputAge.name = 'age';

document.body.appendChild(inputLogin);
document.body.appendChild(inputEmail);
document.body.appendChild(inputAge);

inputLogin.addEventListener('focus', onInputKeyUpped);
inputEmail.addEventListener('focus', onInputKeyUpped);
inputAge.addEventListener('focus', onInputKeyUpped);

inputLogin.addEventListener('keyup', onInputKeyUpped);
inputEmail.addEventListener('keyup', onInputKeyUpped);
inputAge.addEventListener('keyup', onInputKeyUpped);

function onInputFocused (e) {
    e.target.style.border = '1px solid yellow';
}

function onInputKeyUpped (e) {
    if (e.keyCode === 13) {

        // Нажали Enter
        console.log(e.target.value);

    } else if (e.keyCode === 27) {

      // Нажали ESC
      e.target.value = '';

    }
}
</pre>
   </td>
   <td valign=top>
<pre>
function Input (params) {
    this.domElement = document.createElement('input');
    this.domElement.name = params.nameAttr;

    this.domElement.addEventListener('focus', this.onFocused);
    this.domElement.addEventListener('keyup', this.onKeyUpped);

    this.render();
}

Input.prototype.onKeyUpped = function (e) {
    if (e.keyCode === 13) {
        console.log(e.target.value);
    } else if (e.keyCode === 27) {
        e.target.value = '';
    }
};

Input.prototype.onFocused = function (e) {
    e.target.style.border = '1px solid yellow';
};

Input.prototype.render = function () {
    document.body.appendChild(this.domElement);
};

var inputLogin = new Input({nameAttr: 'login'});
var inputEmail = new Input({nameAttr: 'email'});
var inputAge = new Input({nameAttr: 'age'});
</pre>
   </td>
</tr>
</table>

В чём главное преимущество ООП перед продурным стилем? В том, что все свойства и умения конкретного объекта мы
описываем внутри самого объекта. В том, что каждый объект, инстанцированный от конкрентного класса гарантированно
будет обладать всеми свойствами и умениями этого класса. В том, что код сайта больше не похож на спагетти из
разношерстных функций, которые вызывают одна другую не-пойми-в-какой последовательности. Отныне ваш код — это
объекты, наполненные смыслом и достоинством. А вы, программист такого сайта, — единовластный хозяин этих объектов, —
только вы один решаете, какие объекты (и классы) создавать, и как они будут взаимодействовать в вашем скрипте.

Эту идеальную картину омрачает единственный мазок — нативно `ООП` на `Javascript` реализуется с помощью
малопонятного и, прямо скажем, нелицеприятного свойства `prototype`. Но знаете, что? Оказывается можно создавать
объекты красиво, хоть и не нативно. Вам понравится, обещаю. Но об этом через 2 минуты, а пока подведем итоги тому,
что мы узнали.

### Что мы узнали?

`ООП` — это всего лишь ещё один способ организации своего кода.

`Класс` - это нечто вроде правил, по которым создаются объекты определенного типа. Можно думать, что `Класс` - это
вспомогательные шаблоны, что ли. Сам по себе `Класс` не имеет смысла, он нужен для того, чтобы давать жизнь
конкретным объектам.

`Объект класса`, он же объект какого-то типа (как мы его раньше называли) - это специальным образом сгруппированный
код. Если раньше мы группировали свой код преимущественно в функции, то теперь мы предпочитаем организовывать код в
некие объекты, которые обладают некими свойствами и умениями, называемыми соответственно полями и методами объекта.
Такой объект, произведенный от конкретного класса принято называть `инстансом` этого класса, или `экземпляром`, кому как
 нравится.

В `Javascript`-е есть встроенные классы, и мы создавали от них инстансы, не подозревая, что мы это делаем. Когда мы
создавали строковую переменную - мы как бы создавали инстанс класса `String`. Когда мы создавали массив — мы на самом
деле создавали инстанс класса `Array`.

Но встроенных классов нам мало. Нам хочется уметь создавать свои собственные классы объектов, потому что мы
порядком устали устали от процедурного стиля программирования и бесконечного списка своих функций, которые вызывают
друга друга в запутанном порядке, от чего наш код довольно скоро становится плохо управляемым и нерасширяемым.

`ООП` - это способ разделения нашего кода на классы и порождённые ими объекты. Во всех больших языках, вроде `Java`
или `C#` объектно-ориентированный подход программирования "встроен" по умолчанию. Мы хотим привнести его в
`Javascript` и, к счастью, такая возможность есть.

Создать `экземпляр класса` очень просто. Это делает оператор `new`.
Описать сам класс тоже просто — для этого используется, как ни странно, обычная функция.

Внутри этой функции (её ещё называют `конструктором класса`) мы можем объявить все свойства будущих объектов,
которые мы будем создавать оператором `new` (их ещё называют `инстансами класса`). Свойства объявляются с помощью
полей вида `this.something`.

А вот умения класса, а значит и умения каждого инстанцированного от этого класса объекта, мы описываем не в
функции-конструкторе, а в отдельных методах, которые сохраняем в специальном и непонятном поле `prototype`. То есть,
 у каждого конструктора обязательно есть такое служебное поле по имени `prototype`. И именно в нём мы описываем
 методы класса. Почему так придумано в `Javascript` - это отдельная тема, — нельзя сказать, что тема проста для
 понимания. Но хорошо уже то, что её изучить можно сильно позже, или не изучать вовсе.

Дальше мы будем говорить с вами о капсулирования информации в объектах, о наследовании, о способах общения объектов
друг с другом. Но прежде всего мы поговорим о том, как же обойтись без уродующих наш код прототипов. Ну, ужас же!

## Библиотека `inherit`

Всех `js`-программистов не устраивает ситуация с `prototype`. Конечно, возможно среди нас есть такие, кто любит каждое
объявление метода присваивать классу через его прототип. Не знаю, может и есть. Но вообще-то ООП-программисты - народ,
исповедующий красоту в коде. А в прототипах нет ни грамма красоты. Поэтому ООП-программисты придумали
решение, которое в общем виде выглядит, как функция, которая работает с прототипами сама. А мы лишь описываем
классы так красиво, как нам хочется.

Помните, как нам хотелось бы это делать? Я показывал выше код и говорил, что _так_ красиво, только рождает
проблемы:
```javascript
function Input (params) {
    this.myProperty = params.value;

    this.myMethod = function () {
        console.log(this.myProperty);
    };
}
```

То есть, хочется, чтобы класс описывался в одном цельном фрагменте кода, без распыления на объявления методов через
прототипы.

А вот как выглядит ровно этот же код с помощью специализированной функции `inherit`:
```javascript
var Input = inherit({
    __constructor: function (params) {
        this.myProperty = params.value;
    },

    myMethod: function () {
        console.log(this.myProperty);
    },
});
```

Инстанцироваться от него точно так же, как и раньше: `var inputLogin = new Input();`.

И вот каким красивым и понятным становится наш пример уже с использованием функции `inherit`:
```javascript
var Input = inherit({
    __constructor: function (params) {
        this.domElement = document.createElement('input');
        this.domElement.name = params.nameAttr;

        this.domElement.addEventListener('focus', this.onFocused);
        this.domElement.addEventListener('keyup', this.onKeyUpped);

        this.render();
    },

    onKeyUpped: function (e) {
        if (e.keyCode === 13) {
            console.log(e.target.value);
        } else if (e.keyCode === 27) {
            e.target.value = '';
        }
    },

    onFocused: function (e) {
        e.target.style.border = '1px solid yellow';
    },

    render: function () {
        document.body.appendChild(this.domElement);
    }
});

var inputLogin = new Input({nameAttr: 'login'});
var inputEmail = new Input({nameAttr: 'email'});
var inputAge = new Input({nameAttr: 'age'});
```

Никаких тебе прототипов, весь класс `Input` описывается одним логически понятном фрагментом кода. Красота.

Эту функцию придумал и создал наш коллега из Яндекса, — Дмитрий Филатов, — вот
[репозиторий этого проекта](https://github.com/dfilatov/inherit). Почему функция называется именно `inherit` и
что она умеет делать ещё, мы поговорим ниже. А сейчас минутка признательности.

_Дима, спасибо тебе большое!_
_Именно благодаря твоему решению я полюбил программирование в объектно-ориентированом стиле на `Javascript`._

В недалёком будущем в `Javascript` можно будет создавать классы нативно и красиво одновременно. Заглянем в будущее на
мгновение и увидим, как мы перепишем наш класс, когда все браузеры поддержат новый стандарт `Javascript` —
`ECMAScript 2015 (ES6)`:

<table>
<tr>
    <th>Настоящее: с помощью `inherit`</th>
    <th>Будущее: `ECMAScript 2015 (ES6)`</th>
</tr>
<tr>
   <td valign=top>
<pre>
var Input = inherit({
    __constructor: function (params) {
        this.domElement = document.createElement('input');
        this.domElement.name = params.nameAttr;

        this.domElement.addEventListener('focus', this.onFocused);
        this.domElement.addEventListener('keyup', this.onKeyUpped);

        this.render();
    },

    onKeyUpped: function (e) {
        if (e.keyCode === 13) {
            console.log(e.target.value);
        } else if (e.keyCode === 27) {
            e.target.value = '';
        }
    },

    onFocused: function (e) {
        e.target.style.border = '1px solid yellow';
    },

    render: function () {
        document.body.appendChild(this.domElement);
    }
});
</pre>
    </td>
   <td valign=top>
<pre>
class Input {
    constructor: function (params) {
        this.domElement = document.createElement('input');
        this.domElement.name = params.nameAttr;

        this.domElement.addEventListener('focus', this.onFocused);
        this.domElement.addEventListener('keyup', this.onKeyUpped);

        this.render();
    },

    onKeyUpped: function (e) {
        if (e.keyCode === 13) {
            console.log(e.target.value);
        } else if (e.keyCode === 27) {
            e.target.value = '';
        }
    },

    onFocused: function (e) {
        e.target.style.border = '1px solid yellow';
    },

    render: function () {
        document.body.appendChild(this.domElement);
    }
}
</pre>
    </td>
</tr>
</table>

В будущем нам придётся совсем немного переписать наш код, чтобы он работал с нативными классами. А пока будущее не
наступило, мы будем пользовать функцией-хелпером `inherit`. Дима, спасибо тебе большое.

Использовать эту функцию очень просто. Подключите её на страницу любым удобным вам способом — либо в теге `<script>`,
 либо настройте свою `Grunt/Gulp/Webpack/WhatElse?`-сборку, чтобы содержимое файла
 [inherit.js](https://github.com/dfilatov/inherit/blob/master/lib/inherit.js) попало в собранный вами `page.js` и
 пользуйтесь.

Эта функция настолько прекрасна, что в Яндексе не представляют жизни без неё. С её помощью можно не только описывать
 классы. Можно наследовать классы, доопределять и переопределять поля и методы базового класса, вызывать методы
 базового класса из производного. Обо всём этом мы поговорим.

Но прежде - про приватный и публичный интерфейсы объекта.

## Приватный и публичный интерфейсы

Можно считать эту тему краеугольной в `ООП`. Поймём её один раз и будем использовать классы с объектами максимально
эффективно. Поэтому... садимся в машину.

Я уже говорил, я ежедневно езжу на автомобиле, совершенно не разбираясь в его устройстве. Вы точно так же в
жизни пользуетесь множеством предметов, не представляя, насколько сложно они устроены внутри. Да что там далеко
ходить за примером, моей дочери 10 лет и она вообще ничего не знает про устройство её ноутбука. Но видели бы вы, как
 вирутозно она им пользуется.

Вообще-то это правильно — прятать сложное устройство предмета под капот, под крышку, под днище... То есть туда, куда
пользователь устройства не сможет залезть случайно. Пользователю нужно оставлять только минимальный,
но достаточный, набор органов управления. В машине это руль, педали, ручки, кнопки, двери. В компьютере это
клавиатура, дисковод, разъемы для внешних носителей. Самый минимум, но достаточный для эффективного использования
предмета.

Ровно этот же принцип программисты перенесли из жизни в программы. Посмотрим на наш класс.
```javascript
var Input = inherit({
    __constructor: function (params) {
        this.domElement = document.createElement('input');
        this.domElement.name = params.nameAttr;

        this.domElement.addEventListener('focus', this.onFocused);
        this.domElement.addEventListener('keyup', this.onKeyUpped);

        this.render();
    },

    onKeyUpped: function (e) {
        if (e.keyCode === 13) {
            console.log(e.target.value);
        } else if (e.keyCode === 27) {
            e.target.value = '';
        }
    },

    onFocused: function (e) {
        e.target.style.border = '1px solid yellow';
    },

    render: function () {
        document.body.appendChild(this.domElement);
    }
});

var inputLogin = new Inpit({nameAttr: 'login'});
```

Все три метода этого класса можно вызвать от произведенного им объекта. Это сделать очень легко:

```javascript
var inputLogin = new Inpit({nameAttr: 'login'});

inputLogin.render();
inputLogin.onFocused();
inputLogin.onKeyUpped();
```

Но если по-рассуждать, логически, разве когда-нибудь возникнет ситуация, когда мы захотим у объекта `inputLogin`
вызвать метод `onKeyUpped` сами? Снаружи?

Что значит "снаружи", что значит "внутри"? Это просто.

### Приватный интерфейс

**Внутри**  - означает изнутри класса. Когда один метод класса вызывает другой метод этого же класса. Такие вызовы для
 нас даже незаметны, словно спрятаны от нас под капот автомобиля. Вот мы сказали в главном скрипте `var inputLogin =
  new Inpit({nameAttr: 'login'});` и даже не заметили, как произошла целая цепочка сложной работы: оператор `new`
  "нашёл" в нашем коде описание  класса `Input`, запустил конструктор класса, выполнил все операторы, которые там
  описаны, развесил обработчики событий, вызвал у класса метод `render()`, а потом вернул в объект `inputLogin`
  экземпляр класса `Input`.

Много работы произошло под капотом, но мы её не видим. Мы искапсулировали всю эту сложность внутри класса и
пользуемся только внешним интерфейсом класса: `new Input()`. Когда вы будете слышать, как другие программисты
произносят слово "инкапсуляция", знайте, они подразумевают вот такое сокрытие каких-то действий от глаз пользователя.

В нашем случае `внешним пользователем` можно считать главный скрипт на веб-странице, в котором мы создаём инстанс
класса `Input`, а внутренней реализацией — код, инкапсулированный внутри описания класса `Input`.

Верну вас к последнему вопросу. Если по-рассуждать, логически, разве когда-нибудь возникнет ситуация, когда мы
захотим у объекта `inputLogin` вызвать метод `onKeyUpped` сами?

Этот метод должен вызываться только в то мгновение, когда курсор мигает внутри инпута, и вдруг нажимается клавиша на
клавиатуре. Этот метод предназначен _исключительно_ для обработки такой ситуации. А может ли главный скрипт каким-то
образом это мгновение распознать? Очевидно, не может.

Только сам инстанс это знает благодаря тому, что при его инстанцировании в конструкторе (ещё говорят, при
инициализации) вешается слушатель такого события — `this.domElement.addEventListener('keyup', this.onKeyUpped);`.
Только конретный экземпляр инпута может вызывать метод `onKeyUpped`. То есть этот метод может вызываться только внутри.

Такие методы, которые вызываются только внутри класса, называют приватными. В нашем классе  `Input` я вижу два таких
метода - `onKeyUpped` и `onFocused`. Второй метод я отнёс к приватному ровно по тем же соображениям, что и первый.

_Почему метод `render` я не считаю приватным, расскажу чуть позже._

Приватные методы только для внутреннего использования. Это очень важно. И удобно. Докажу вам на простом примере.

<table>
<tr>
    <th>Было</th>
    <th>Стало</th>
</tr>
<tr>
   <td valign=top>
<pre>
var Input = inherit({
    __constructor: function (params) {
        this.domElement = document.createElement('input');
        this.domElement.name = params.nameAttr;

        this.domElement.addEventListener('focus', this.onFocused);
        this.domElement.addEventListener('keyup', this.onKeyUpped);

        this.render();
    },

    onKeyUpped: function (e) {
        if (e.keyCode === 13) {
            console.log(e.target.value);
        } else if (e.keyCode === 27) {
            e.target.value = '';
        }
    },

    onFocused: function (e) {
        e.target.style.border = '1px solid yellow';
    },

    render: function () {
        document.body.appendChild(this.domElement);
    }
});
</pre>
    </td>
   <td valign=top>
<pre>
var Input = inherit({
    __constructor: function (params) {
        this._domElement = this._createDOMElement(params.nameAttr);

        this._domElement.addEventListener('focus', this.onFocused);
        this._domElement.addEventListener('keyup', this.onKeyUpped);

        this.render();
    },

    /**
     * Создаёт DOM-элемент <input>
     *
     * @private
     * @param {String} name Значение для атрибута name
     * @returns {HTMLElement}
     */
    _createDOMElement: function (name) {
        var domElement = document.createElement('input');
        domElement.name = name;
        domElement.type = 'text';

        return domElement;
    },

    _onKeyUpped: function (e) {
        if (e.keyCode === 13) {
            console.log(e.target.value);
        } else if (e.keyCode === 27) {
            e.target.value = '';
        }
    },

    _onFocused: function (e) {
        e.target.style.border = '1px solid yellow';
    },

    render: function () {
        document.body.appendChild(this._domElement);
    }
});
</pre>
    </td>
</tr>
</table>

Во-первых все приватные поля и методы принято предварять символом нижнего подчеркивания. Так легче отличать приватное
 от публичного. Это я и сделал в нашем классе. Но не на это я хотел обратить ваше внимание.

Смотрите, я ввёл новый приватный метод `_createDOMElement` и перенёс в него всё, что относится к созданию
`HTMLElement`. Я пометил этот метод, как приватный, с помощью символа нижнего подчеркивания и ещё написал понятный
`JSDoc`, в котором так же указал, что этот метод приватный.

Во-первых так лучше - когда в нашем классе каждый метод выполняет одну простую задачу. Ведь раньше наш конструктор
сам и создавал элемент, и вешал обработчики событий, и звал метод для отображения элемента на странице. Сейчас
конструктор не делает сам всё сразу - он лишь делегирует полномочия другим методам класса. Конструктор стал
командиром, приказы раздал и доволен. Но и не в этом фишка.

Смотрите на метод `_createDOMElement`. Так как этот метод мы считаем приватным, то он будет вызываться
_исключительно_ из методов этого же класса. Верно? Это как в машине — я догадываюсь, что под капотом есть какие-то
шестеренки, ремни, поршни. Но думать о них мне не нужно — разработчики машины скрыли от меня всё сложное устройство.
И если завтра на Тех.Обслуживании механик выкинет один ремень и вставит новый, я об этом даже не узнаю — мне
главное, чтобы машинка бегала.

В этом сила приватных методов. Сегодня в методе `_createDOMElement` я создаю `HTMLElement` с помощью нативной
`javascript`-функции `createElement`. Но это сегодня. А завтра могу захотеть переписать реализацию этого метода,
чтобы создавать элемент с помощью `jQuery`-хелперов. Но "снаружи" класса об этом никто не узнает, ведь приватные
методы никто не имеет права вызывать.

Больше того. Если мы будем в нашей программе строго выполнять требование "никогда не вызывать приватные методы чужого
объекта", мы получаем возможность хоть трижды в день менять реализацию приватных методов каждого класса. Это никак не
 поломает код основной программы. Только бы не ломать публичные методы! И если соблюдать это требование,
 время от времени возникающая потребность в рефакторинге программы уже не будет приносить столько боли, как раньше,
 когда мы писали процедурным способом.

Ещё раз, закрепим.

**Так нельзя**. Запрещено "снаружи" класса вызывать приватные методы класса. Технически вам этого никто не запретит -
 технически вы способны это сделать. Нельзя. ООП-программисты так не делают и вам не советуют.
```javascript
var inputLogin = new Inpit({nameAttr: 'login'});
inputLogin._createDOMElement('another-name');
```

**А так можно**. Потому что мы зовём публичный метод. То есть такой, который **предназачен** для того, чтобы его
вызывали снаружи класса.
```javascript
var inputLogin = new Inpit({nameAttr: 'login'});
inputLogin.render();
```

### Публичный интерфейс
Конечно, мы делаем странное в предыдущем фрагменте кода — вызываем метод `render` у объекта `inputLogin` в тот
момент, когда этот метод уже был однократно вызван из конструктора класса. И ещё странно, что в текущей реализации
метод жестко рендерит инпут в `document.body`. Это неправильно. Переделаем:

```javascript
var Input = inherit({
    __constructor: function (params) {
        this._domElement = this._createDOMElement(params.nameAttr);

        this._domElement.addEventListener('focus', this.onFocused);
        this._domElement.addEventListener('keyup', this.onKeyUpped);
    },

    /**
     * Создаёт DOM-элемент <input>
     *
     * @private
     * @param {String} name Значение для атрибута name
     * @returns {HTMLElement}
     */
    _createDOMElement: function (name) {
        var domElement = document.createElement('input');
        domElement.name = name;
        domElement.type = 'text';

        return domElement;
    },

    _onKeyUpped: function (e) {
        if (e.keyCode === 13) {
            console.log(e.target.value);
        } else if (e.keyCode === 27) {
            e.target.value = '';
        }
    },

    _onFocused: function (e) {
        e.target.style.border = '1px solid yellow';
    },


    /**
     * Отображает инпут в дереве документа
     *
     * @param {HTMLElement} parentNode Родительский элемент, в который будет помещен инпут
     */
    render: function (parentNode) {
        parentNode.appendChild(this._domElement);
    }
});

var inputLogin = new Inpit({nameAttr: 'login'});
inputLogin.render(document.body);
```

Обратите внимание, вызов `this.render()` исчез из конструтора. Теперь мы зовём этот метод снаружи класса строкой
`inputLogin.render(document.body);`. И теперь этот метод принимает один параметр - `HTMLElement`, в который мы хотим
поместить этот инпут. Стало удобнее.

Теперь конструктор только создаёт приватное поле `_domElement` и навешивает на него обработчики событий, и больше
ничего не делает. А потом мы - программисты — решаем, как себя вести объекту. Говорим ему — отобразись внутри `document
.body`. А захотим, отобразим его в любом другом `HTML`-элементе.

Публичный интерфейс ломать нельзя!

При создании классов принято тщательно продумывать публичный интерфейс — какие методы будут светиться наружу. Это очень
тщательно продумывают, а когда создают публичные методы, больше никогда их не меняют. По крайней мере стараются.
Потому что в программе объект одного класса часто вызывает методы объекта другого класса через вызов публичных
методов. Если вдруг вы отрефакторите какой-то класс и убьёте публичный метод (или хотя поменяете местами ожидаемые
параметры), вы скорее всего сломаете всю программу.

Публичный интерфейс ломать нельзя!

Отдал я машину на Тех.Обслуживание. Через два часа вернулся, завёл машину, а механик, оказывается, переставил местами
педали сцепления, тормоза и газа! Отрефакторил, понимаешь! Я никуда не смогу уехать. Ни-ку-да. Просто потому что я, как
объект класса Человек, научился работать с машиной как с объектом класса Автомобиль при помощи публичного метода
Педали в определенном порядке — слева сцепление, справа газ, а между ними тормоз. Этот порядок вшит в мою голову
намертво. Я даже если попытаюсь уехать из СТО, приноравливаясь к новому расположению педалей, я на первом же
(первом!) перекрестке создам ДТП. Потому что **нельзя ломать публичный интерфейс**!

Меняйте приватные методы, удаляйте или добавляйте их на здоровье, хоть и трижды в день - до завтрака. Но публичные
методы а) не должны исчезать и б) должны выполнять ту функцию, ради которой публичный метод создан.

Например, взбрело мне что-то в голову, и я переписал класс `Input` полностью:
```javascript
var Input = inherit({
    __constructor: function (params) {
        this._domElement = document.createElement('input');
        this._domElement.name = params.nameAttr;
        this._domElement.type = 'text';

        this._domElement.addEventListener('focus', function (e) {
            e.target.style.border = '1px solid yellow';
        });

        this._domElement.addEventListener('keyup', function (e) {
            if (e.keyCode === 13) {
                console.log(e.target.value);
            } else if (e.keyCode === 27) {
                e.target.value = '';
            }
        });
    },

    /**
     * Отображает инпут в дереве документа
     *
     * @param {HTMLElement} parentNode Родительский элемент, в который будет помещен инпут
     */
    render: function (parentNode) {
        parentNode.appendChild(this._domElement);
    }
});

var inputLogin = new Inpit({nameAttr: 'login'});
inputLogin.render(document.body);
```

C точки зрения пользователя этого класса не изменилось ничего. Пользователь как пользовался этим классом? Да вот так:
```javascript
var inputLogin = new Inpit({nameAttr: 'login'});
inputLogin.render(document.body);
```
Пользователь только создавал инстанс класса, а потом вызывал метод `render`. Всё так и осталось.

А с точки зрения внутреннего устройства класса поменялось всё — я удалил все приватные методы. Вся работа теперь
возложена на конструктор. Но я не тронул публичный метод, и только благодаря этому в моей программе ничего не
сломается. Вот почему ООП делает ваш код не только красивым, логичным, но и надёжным.

Но, конечно, мы за это "расплачиваемся" тем, что нам нужно твёрдо соблюдать несколько правил:

1. Публичный интерфейс ломать нельзя!

2. Приватные методы чужого объекта вызывать напрямую нельзя!

Но эти правила выполнять несложно ;)

В этом разделе статьи я излишне много использовал восклицательных знаков и запретов. Но это больше для устрашения
новичков. Если вы новичок, лучше **сразу** учитесь правильно работать с приватным и публичным интерфейсами классов.
Конечно, эти правила нарушают, этим грешат и умудренные опытом ООП-адепты. Но лучше эти два запрета соблюдать всегда.

Это как с правилом дорожного движения "Запрещается пересекать сплошную линию, разделяющую встречные потоки движения
автомобилей". Я к этому правилу отношусь почтительно — **сплошную просто так на дороге не рисуют**. Если она на дороге
есть, значит **именно в этом месте** она нужна, даже если я, — такой опытный и крутой водитель, — не вижу никакой
опасности. Опасности не вижу, а она есть. Значит, не настолько я опытен, если не способен распознать, зачем тут
нанесли сплошную. В Правилах Дорожного Движения нет лишних правил, все выстраданы чужими жизнями.

В ООП не так всё сурово, жизнями не наказывают. Но часами жизней, проведенными в поисах внезапной поломки программы,
— вполне себе. Не нарушайте :)

## Наследование

Наследование — это третий принцип ООП из четырёх.

_О первых двух мы уже поговорили выше, это были принципы абстракции и инкапсуляции. О четвертом - полиморфизме — 
поговорим позже. А сейчас о наследовании._

На свете всё на всё похоже: 

Змея – на ремешок из кожи;

Луна – на круглый глаз огромный;

Журавль – на тощий кран подъемный;

Кот полосатый – на пижаму;

Я – на тебя, а ты – на маму.

Чудесные стихи [Романа Сефа](https://ru.wikipedia.org/wiki/Сеф,_Роман_Семёнович) как раз о наследования в `ООП` :)

В жизни каждый ребенок наследует **какие-то** черты лица, особенности фигуры и даже привычки **обоих** своих родителей.
В `Javascript` класс может наследоваться только от **одного** "родителя", у которого перенимает **сразу все** поля и 
методы. Технически это происходит так:
```javascript
var Textarea = inherit(Input, {
    __constructor: function (params) {
        this.__base(params);
    }
});

var textarea = new Textarea({nameAttr: 'comment'});
textarea.render(document.body);
```

Мы только что объявили новый класс `Textarea`, который унаследовали от класса `Input`.
"Унаследовали" означает, что у `Textarea` появятся все те же свойства и методы, что есть у класса `Input` плюс
свои собственные. В этом и есть суть наследования. К этому мы ещё вернемся, а пока обратите внимание, с помощью чего
возможно наследование в `Javascript`.

С помощью `inherit` мы не только создаём классы, мы ещё и наследуем. Функция `inherit` умеет принимать
разное количество параметров, и в зависимости от количества, сама понимает, что конкретно делать:
```javascript
// Создаёт класс А с нуля.
var A = inherit({
    // методы класса A
});

// Создаёт класс B, как наследника от класса A
var B = inherit(A, {
    // Методы класса B
});
```

_Конечно, это же можно сделать на чистом `Javascript` с помощью прототипов. Но я не хочу этим заниматься. Если вам
очень любопытно, почитайте статью Ильи Кантора 
["Наследование классов в JavaScript"](https://learn.javascript.ru/class-inheritance). Но лучше не надо. Пока не надо.
 Чтобы не перегружать мозг ненужной сейчас информацией._

В нашем примере у класса `Textarea` нет собственных методов, кроме `__constructor`, который мы добавили, чтобы
вызвать этот же метод в базовом классе:
```javascript
var Textarea = inherit(Input, {
    __constructor: function (params) {
        this.__base(params);
    }
});
```

Конструкция `this.__base()` означает "вызови этот же метод у базового класса". Этим методом конструктор `Textarea`
вызовет конструктор `Input` и передаст в него аргументом переменную `params`, как бы "прокинет" её внутрь `Input`. И с
этого мгновения любые инстансы `Textarea` будут обладать всеми полями и методами, которые есть у каждого инстанса
`Input`.

_Вообще лучше вместо `this.__base(params)` написать `this.__base.apply(this, arguments)`, тогда не нужно будет
прокидывать конкретные `params` — в базовый класс улетят все аргументы. Но вы и так знаете, что такое `apply`. А
если не знаете, [прочитайте](https://learn.javascript.ru/call-apply) и знайте :)_

Класс `Textarea` в текущем виде совершенно бесполезен. Просто полная копия класса `Input`. Зачем он? Зачем такое 
наследование нужно? 

Если по-простому, наследование придумано для того, чтобы сделать точно "такой же класс, только 
чуть-чуть иной".

К примеру, класс `Textarea` полностью повторяет функциональность класса `Input`, только вместо тега 
`<input>` нужно создавать тег `<textarea>`. Наследование - для этого. 
 
Такая задача решается с помощью переопределения метода базового класса.

### Переопределение и доопределение методов

Я думаю, вы уже поняли, что базовым классом называют тот, от которого наследуют. А тот класс, который 
наследуется от базового, называют производным. Запомним и эти термины.

Переопределение базового метода — простая операция — создаем в прозводном классе метод с точно таким же именем, как в 
базовом. И всё.

```javascript
var Textarea = inherit(Input, {
    __constructor: function (params) {
        this.__base.apply(this, arguments);
    },
    
    /**
     * Создаёт DOM-элемент <textarea>
     *
     * @private
     * @param {String} name Значение для атрибута name
     * @returns {HTMLElement}
     */
    _createDOMElement: function (name) {
        var domElement = document.createElement('textarea');
        domElement.name = name;

        return domElement;
    }
});
```
