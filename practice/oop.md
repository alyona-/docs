# Объектно-ориентированное программирование (ООП).

`ООП` - это не что-то магическое и доступное только гениям программирования. Даже школьник, который по информатике 
не вылезает из троек, способен понять, что такое `ООП`, потому что объектно-ориентированное программирование — это лишь
 _ещё один_ способ организации своего кода. Всё! 
 
`ООП` - это когда вы пишете свой `javascript`-код не в виде плоского списка функций, а в виде так называемых 
`Классов` и `Объектов`. Непонятно, согласен :)

В классических учебниках эту тему пытаются объяснять на примере автомобиля.

Мол, автомобиль - это класс объектов. Если выражаться привычными нам словами, это категория объектов. Эта категория (класс) имеет характерные признаки - 4 колеса, двигатель, салон для пассажиров. Автомобили умеют двигаться в пространстве и перевозить людей. И там, в учебниках, утверждается, мол, **все** автомобили имеют **все эти** характерные признаки, а например, лифты не имеют **всех этих** признаков, а имеют какие-то свои признаки, значит они принадлежат к другому классу объектов.

А объект — это, мол, конкретная машина, созданная на конкретном автомобильном заводе. Она имеет все характерные признаки класса автомобиль (4 колеса, двигатель, салон...), но это уже не абстрактный класс (не абстрактная категория автомобилей), а вполне себе реальная штуковина, которую можно пощупать, в неё можно сесть, завести и поехать на море.

То есть класс, объясняли в учебнике, - это сущность абстрактная, шаблонная, она лишь описывает признаки (или правила), по которым нужно создавать конкретный экземпляр. Экземпляр класса. Или другими словами, объект класса. А вот объект - это уже  конкретная реализация этого класса.

Я когда читал эти объяснения в учебнике, я всё понимал. Про автомобили - всё понимал. Про `ООП` в `Javascript` - 
ничего не понимал. Как знания про автомобили применить к моим программам? Непонятно. 

Попыток объяснить эту тему существует множество — их легко найти в учебниках про настоящие объектно-ориентированные 
языки, среди которых на слуху `Java` и `C#`. Сейчас эти попытки можно обнаружить и в учебниках про `Javascript`. Но 
я всё же собираюсь предпринять свою собственную, потому что меня не устраивают объяснения всех этих бесспорно 
уважаемых людей. Я вам объясню эту тему так, как собираюсь объяснять её своей дочери годика эдак через четыре. То 
есть, понятно. И не про автомобили и лифты, а именно про `Javascript`.

## Что нужно знать?

К тому моменту, когда дочь будет готова воспринимать эту тему, она должна будет понимать, что такое переменные, какие типы переменных существуют в `javascript`, какие методы существуют у встроенных типов (например, у строк, у чисел, у массивов). Дочь должна уметь создавать функции, уметь их вызывать и принимать от них результаты.

Если всей этой базы не понимать, задаваться вопросом, что такое объектно-ориентированное программирование, совершенно незачем. ООП - это абстракция над базовыми возможностями `javascript`. Если не знать базовых возможностей, глупо лезть в дебри.

Я предполагаю, что вы прекрасно разбираетесь в основах. Поэтому вперёд.

## Вообще-то, вы умеете писать объектно-оринтированный код!

Конечно же! Не ослышались. И хотя даже школьник-троеничник знает, что `Javascript` вообще ни разу не 
объектно-ориентированный язык, вам следует знать, что когда вы пишете `javascript`-программу, вы чуть ли не в 
каждой строчке своего кода создаёте `Объекты` из `Классов` и оперируете ими мастерски, только не осознаёте этого. 

Каждый из нас _уже умеет_ писать объектно-ориентированные программы.

```javascript
var name = 'BEViS';
```
Что в этом коде происходит? Ничего  магического, скажете вы. Ну, создаём переменную `name` строкового типа и присваиваем
 ей значение 'BEViS'. Вам этот оператор  совершенно понятен. Ну, переменная. Ну, строкового типа. Ну и?

На самом деле, этот же оператор может быть записан иначе. Вы это наверняка знаете. Или знали раньше, но забыли:
```javascript
var name = new String('BEViS');
```
Этот код совершенно идентичен предыдущему. Но я попробую предположить, что разработчики `Javascript` пожалели нас, бедных, и дали нам возможность писать это же короче - без вызова оператора `new` и без указания типа `String`. Спасибо им. Но что такое `new String()`? Сравним описания:

Создаём **переменную** `name` строкового **типа** и присваиваем *переменной* значение 'BEViS':
```javascript
var name = 'BEViS';
```

Создаём **объект** `name` строкового **класса** (то есть, класса `String`) и присваиваем *объекту* значение 'BEViS':
```javascript
var name = new String("BEViS");
```

То есть вместо слова `Тип` можно смело говорить слово `Класс`. Считайте, это одно и то же. А вместо слова ``Переменная`` можно смело говорить слово ``Объект``.

Вы так не говорили никогда, я тоже так никогда не говорил — так говорить нас не учили ни в одном учебнике. Но если мы
  хотим научиться писать объектно-ориентированные программы, нужно нуачиться смотреть на свои уже написанные программы 
  под новым углом. Мне кажется, если вы поймёте, что любая переменная, которую вы создавали в своей жизни, на самом 
  деле никакая не переменная, а `Объект` какого-то `Класса`, понять всё остальное про `ООП` будет легко. Попробуйте 
  вместе со мной относиться к переменным именно так. Договорились, пробуем?

Итак, когда вы создаёте строковую переменную, на самом деле вы создаёте объект строкового класса. Или "экземпляр класса String". Замысловато звучит, чужеродно даже. Но так принято, все ООП-адепты выражаются именно такими словами и другу друга понимают. И мы привыкнем, и мы научимся.

Итак, когда мы пишем `var name = 'BEViS'`, на самом деле мы создаём не строковую переменную, а экземпляр класса "Строка". Или, другими словами, объект класса "Строка".

В учебниках про `javascript` вы на первых же страницах читали про встроенные типы данных. Вы, конечно, их знаете:
- String
- Number
- Boolean
- ...

Давайте перестанем думать о них, как о **типах** данных, а будем относиться к ним, как к **классам** данных.

_Правильно это с академической точки зрения или нет, я уверен, вообще не важно. Я хочу, чтобы вы осознали прямо сейчас — вы каждый день пишете программы с использованием классов и объектов, только не называете их этими словами. Как только вы это осознаете, вы легко поймёте, как создавать и как пользоваться своими собственные классами и объектами. Но про свои классы и объекты чуть позже. А пока начнём привыкать к новым словам._

Как любая реальная машина имеет 4 колеса, двигатель и салон, так и любой объект, созданный из класса `String` имеет имеет свой характерный набор признаков. Это же понятно, да?

```javascript
var name = new String("BEViS");
console.log(name.length); // 5
```

Мы только что создали объект `name`, и у него вдруг появляется свойство `length`, хотя мы такое свойство не определяли. Оно появилось само собой. Откуда? Вы прекрасно знаете, что любая строковая переменная обладает таким свойством, эка невидаль. Но давайте подумаем об этом по-новому. Покатайте в уме такое объяснение: любой экземпляр класса `String` обладает свойством `length`. Как только мы создали новый экземпляр класса с помощью оператора `var name = new String('BEViS')` (или с помощью шотката `var name = 'BEViS'`, что одно и то же ) и сохранили его в объекте `name`, созданный объект приобрел сразу все характерные признаки класса `String`.

 У любой строки есть такая вещь, как длина строки. Это признак строки? Признак, конечно. А есть ли такой признак у числа? Правильнее было бы задать этот вопрос другими слоами: "А есть ли точно такой же признак у объекта, созданного от класса `Number`"? Нет.

 Доказываю. Создаём объект класса `Number` и спрашиваем у него длину:
```javascript
var age = new Number(36);
console.log(age.length); // undefined
```
Нет такого свойства у экземпляра класса `Number`. Да вы и сами это знаете, только никогда не рассуждали об этом словами `Класс` и `Объект`.

На заводе конкретную машину делают по правилам класса "Автомобиль". А в программах на `js` мы создаём строковые, числовые и булевские переменные с помощью встроенных в `Javascript` классов `String`, `Number`, `Boolean`.

Не только примитивные объекты мы создаём.

Вы писали такое множество раз:
```javascript
var data = [];
```

Это тоже шоткат. На самом деле это тоже создаётся экземпляр класса `Array`:
```javascript
var data = new Array();
```

Вы поняли, что в `javasсript` вы всё время создавали объекты из классов? Вы этим занимались всю свою жизнь, только не думали об этом в таком ключе.

Чтобы окончательно убедить вас в этом, последний довод.

Вы когда-нибудь генерили картинки налету и вставляли в DOM? Конечно. Не таким ли образом вы это делали?
```javascript
var logo = new Image();
logo.src = "picture-of-your-company.jpg";
logo.alt = "Company's Logotype";
logo.title = "Изготовление сайтов под ключ";
document.body.appendChild(logo);
```

Этих 4-х строк достаточно, чтобы в теге `body` появился новый тег
```html
<img src="picture-of-your-company.jpg" alt="Company's Logotype" title="Изготовление сайтов под ключ">
```

В результате
- мы увидим на странице изображение, реализованное тегом `img`.
- браузер навесит на изображение какие-то дефолтные `CSS`-стили.
- снабдит изображение своим собственным особенным поведением:
  - если вдруг картинка по `HTTP` не подгрузится, на её месте браузер покажет текст "Company's Logotype"
  - а если пользователь подведет курсор мыши к картинке, браузер покажет всплывающий тултип с текстом "Изготовление сайтов под ключ"".

Для вас это вообще не новость. Но задумайтесь — мы написали один простой оператор `new Image()` и получили объект, который обладает сразу и  `HTML`-разметкой, и `CSS`-стилями и интерактивным поведением. Получается, что в браузер встроен класс объектов `Image`. Когда мы написали оператор `new Image()`, мы создали экземпляр класса `Image`.

_Кстати, экземпляр класса ещё называют инстансом класса от англ. ["instance"](https://translate.yandex.ru/?text=%D1%8D%D0%BA%D0%B7%D0%B5%D0%BC%D0%BF%D0%BB%D1%8F%D1%80&lang=ru-en)._

Это и называется `Объектно-Ориентированное Программирование`.

Ах, как жаль, что таких встроенных в браузер классов очень мало. Почему нет класса `Input`, `Button`, `Form`? Как было бы легко программировать веб-сайты, если бы таких классов было много и сразу. Но их нет. Это минус. Зато их можно создавать самим, и это плюс. Цель этого туториала — показать вам, что создавать свои собственные классы - это очень просто. Программировать в ООП-стиле на `Javascript` - это просто и удобно.

Попробовав это один раз, вы влюбитесь в ООП-стиль и будете удивляться, как же вы программировали раньше без ООП?

Подводём быстрые итоги.

В `Javascript` мы всё время оперируем не просто переменными (как мы всегда думали), а исключительно конкретными инстансами классов. Создаём ли мы строковую переменную или чисельную, или логическую, или массив, или функцию(!), или картинку — на самом деле мы создаём экземпляры соответствующих классов `String`, `Number`, `Boolean`, `Array`, `Function` или `Image`. Вы делали это в каждой программе. Вы умеете это делать в совершенстве.

Только вы использовали _уже существующие_ в `Javascript` классы. А теперь нам хочется у меть создавать свои собственные классы, чтобы сделать код ещё более удобным.

## Как мы программируем по-старинке.

Начинающие веб-программисты думают про `web`-страницы, как про набор `html`-тегов. Например, элементы формы "текстовое поле" - это тег `<input type="text">`. Как на странице может появиться такой тег?

1. Сервер может построить `html` страницы и отдать в браузер. И в этом `html` где-то внутри `body` уже будет такой тег.
2. Мы можем на стороне браузера сгенерить такой тег в клиенстком `js`.

Серверную генерацию рассматривать не будем, это скучно. Хочется веселья. Как мы можем сгенерить инпут налету?
```javascript
var myInput = document.createElement('input');
myInput.type = 'text';
document.body.appendChild(myInput);
```

Или можно с помощью jQuery:
```javascript
var myInput = $('<input type="text">').appendTo('body');
```

В обоих случаях внутри тега `body` появится новый тег `input`.

Нам хочется, чтобы этот инпут взаимодействовал с пользователем.  Например:
1. Если пользователь поставил курсор в поле, обвести поле фокусной рамкой нужного цвета.
2. Если поле находится в фокусе, и пользователь ввел какой-то текст в поле, а затем нажал кнопку `ESC`, очистить поле от введенного значения.
3. Если поле находится в фокусе, и пользователь нажал кнопку `Enter`, вывести введенное значение в консоль браузера.

Такого поведения браузер не обеспечил для вновь созданного инпута. Значит это должны сделать мы. Предположим, что вы пишете с использованием jQuery, тогда ваш код будет выглядеть приблизительно так:

```javascript
// Создаём инпут и добавляем в DOM
var myInput = $('<input type="text">').appendTo('body');

// Слушаем событие focus
myInput.focus(onInputFocused);

// Слушаем нажатие на клавиши клавиатуры
myInput.keyup(onInputKeyUpped);

// Описываем обработчик фокуса
function onInputFocused (e) {
    e.target.css('border', '1px solid yellow');
}

// Описываем обработчик нажатия на клавиши клавиатуры
function onInputKeyUpped (e) {
    if (e.keyCode === 13) {

        // Нажали Enter
        console.log(e.target.value);

    } else if (e.keyCode === 27) {

      // Нажали ESC
      e.target.value = '';

    }
}
```

Возможно, я допустил ошибки. Скорее всего, этот код можно оптимизировать. Не сомневаюсь, вы напишете его лучше.

Но я не об этом. Давайте подумаем, где этот код мы пишем? Я предполагаю, что у вас есть какой-то `page.js` файл, в котором вы пишете всю программу. Этот `page.js` подключается на веб-страницу с помощью тега `<script src='page.js'></script>`. И вы представляете себе очень хорошо, что когда этот файл загрузится в память браузера, запустится интерпретатор языка `Javascript`, который будет читать каждую строку в вашем файле `page.js` сверху вниз и выполнять одну за другой. По-строчно, одну за одной.  В какой-то момент интерпретатор дойдёт до строк, где мы создаём инпут и навешиваем на него обработчики событий. Выполнит операторы в этих строках и пойдёт дальше. С этим проблем нет. Это вы понимаете. А что тут не понять, спросите вы?

У меня один вопрос. А если мы создаём не один инпут? Если мы должны создать два, три, четыре инпута. На что это станет похоже. Я вам покажу:

```javascript
//  Создаём три инпута и добавляем в DOM
var inputLogin = $('<input type="text" name="login">').appendTo('body');
var inputEmail = $('<input type="text" name="email">').appendTo('body');
var inputAge = $('<input type="text" name="age">').appendTo('body');

// Слушаем событие focus на каждом инпуте
inputLogin.focus(onInputFocused);
inputEmail.focus(onInputFocused);
inputAge.focus(onInputFocused);

// Слушаем нажатие на клавиши клавиатуры на каждом инпуте
inputLogin.keyup(onInputKeyUpped);
inputEmail.keyup(onInputKeyUpped);
inputAge.keyup(onInputKeyUpped);

// Описываем обработчик фокуса
function onInputFocused (e) {
    e.target.css('border', '1px solid yellow');
}

// Описываем обработчик нажатия на клавиши клавиатуры
function onInputKeyUpped (e) {
    if (e.keyCode === 13) {

        // Нажали Enter
        console.log(e.target.value);

    } else if (e.keyCode === 27) {

      // Нажали ESC
      e.target.value = '';

    }
}
```

Уже некрасиво. А если нам не только  инпуты создать надо, а ещё форму. А ещё шапку сайта. Или подвал. Или вообще все-все элементы на странице нам надо создавать налету? Создавая код по старинке, мы получим огромную простыню операторов. Интерпретатор `Javascript` жаловаться не будет, ему всё равно - он все прочитает и выполнит. Но ведь нам, людям, такой код читать и поддерживать трудно. Больно.

_Конечно, можно этот код разносить по нескольким файлам, а потом склеивать их в один `page.js` с помощью какого-то сборщика вроде `Grunt`, `Gulp` и т.п. Я вам так скажу - не только можно, а нужно. Необходимо! Этим вы хотя бы немного облегчите себе работу с этим кодом._

Но просто разносить такой код по отдельным файлам мало помогает.

Вот, если бы (давайте помечтаем вслух) в браузере уже существовал специальный класс `Input`? А в нём были бы описаны все нужные обработчики событий? Как бы мы тогда создали три инпута?

Наверное так:
```javascript
//  Создаём три инпута
var inputLogin = new Input({name: 'login'});
var inputEmail = new Input({name: 'email'});
var inputAge = new Input({name: 'age'});

// Добавляем в DOM
document.body.appendChild(inputLogin);
document.body.appendChild(inputEmail);
document.body.appendChild(inputAge);
```

Вставка в DOM никуда бы не делась. А вот описывать обработчики для каждого инпута нам  уже не нужно. _Было бы_ не нужно. Красота.

К счастью, мы можем такую красоту сделать сами.

## Создаём объекты из классов — оператор `new`

Об операторе `new` можно почитать в учебнике Ильи Кантора: [https://learn.javascript.ru/constructor-new](https://learn.javascript.ru/constructor-new). Прочитайте обязательно.

Но даже если не прочитали, вы уже поняли, что оператор `new` нужен для того, чтобы создать инстанс какого-то класса, экземпляр этого класса, конкретный объект класса. Что происходит под капотом этого оператора, прямо сейчас совершенно не важно знать. Важно понять одно - для создания инстансов класса в языке `Javascript` всё есть.

Чего в нём нет, так это _красивого_ способа описывать свои собственные Классы. Слово "красивого" я выделил курсивом не случайно. Нет именно красивого способа. А вообще-то такой способ есть. Он странный и чужеродный для понимания человеком, но он есть. И мы сейчас его изучим.

Раз уж браузер не обеспечил нас, разработчиков, классом `Input`, напишем его сами.

Напомню, создавать инстанс этого класса мы хотим так:
```javascript
var inputLogin = new Input({name: 'login'});
```

## Описываем свой класс с помощью `Function`

Вы прекрасно знаете, что такое функции. Вы создавали их так:
```javascript
function getValue () {
    // ...  
}
```

Или так:
```javascript
var getValue = function () {
    // ...  
}
```

А знаете, как описать класс `Input`? А вот как:
```javascript
function Input () {
    // ...

    return this;
}
```

Забавно, да? Любая функция может стать классом, если выполнить два условия — одно критичное, второе некритичное.

1. Имя функции начинается с заглавной буквы. Это некритичное требование, ему можно не следовать. Но лучше его выполнять, чтобы вы сами могли отличить по именам, где простая функция, а где целый класс.

2. Функция должна вернуть ключевое слово `this`.

Вот как я теперь создам инстанс класса `Input`:
```javascript
function Input (params) {
    this.name = params.name;
    return this;
}

var inputLogin = new Input({name: 'login'});
console.log(inputLogin.name); // --> login
```

Что произошло?

Я создал объект класса `Input`. Создал инстанс (ещё говорят, инстанцию) класса. То есть я создал конкретный инпут. Да, этот инпут пока ничего не умеет - ни html для себя создавать, ни реагировать на действия пользователя — ничего. Всё, что он умеет - хранить в себе поле `name` и заполнять его данными, которые передали при инстанцировании класса `Input`.

Мудрено? :)

И тут мы вернемся с вами к классическому примеру с машинами. Самое время :)

Есть набор правил, по которым создают автомобили. Эти правила гласят, что у любого автомобиля есть набор неких свойств и неких умений.

Например, любой автомобиль должен иметь 4 колеса (обычно, у машин всё таки 4 колеса, хотя были попытки сделать и трёхколесные). У автомобиля должен быть двигатель. Руль. Двери. Салон для пассажиров. С точки зрения ООП эти свойства называются `полями` автомобиля.

Ещё автомобиль должен уметь двигаться. Должен уметь останавливаться. Двери должны уметь открываться и закрываться, чтобы в салон могли сесть пассажиры. С точки зрения ООП эти все умения называются `методами` автомобиля.

_То есть свойства объекта мы в ООП называем "полями", а умения объекта называем "методами". Почему такие названия, сейчас не важно. Просто  запомните: когда встретите слова "поле объекта" или "поле класса", вспоминайте свойства автомобиля. А когда встретите "метод объекта" или "метод класса", вспоминайте умения автомобиля._

Вернемся к нашему классу `Input` и созданному из него объекту `inputLogin`.
```javascript
function Input (params) {
    this.name = params.name;
    return this;
}

var inputLogin = new Input({name: 'login'});
console.log(inputLogin.name); // --> login
```

Как мы говорили, объект `inputLogin` ничего не умеет - у него нет никаких умений, нет никаких методов. Но у него есть своё собственное свойство, которое хранится в поле `name` и которое можно получить через конструкцию `inputLogin.name`. Откуда оно взялось?

Это понятно. Поле `name` описано в классе `Input`. Благодаря оператору `new Input` мы создали экземпляр класса, который автоматически приобрёл все свойства класса `Input`. У класса `Input` есть пока только одно единственное свойство, описанное в поле `this.name`. А потом класс `Input` возвращает `this`. Значит и у объекта `inputLogin` будет только оно одно. Но будет совершенно точно.

Вам это ничего не напоминает? В самом начале мы рассматривали пример с инстансами строки и числа. И мы говорили, что `var name = "BEViS"` — это то же самое, что `var name = new String("BEViS")`. Следовательно в переменной `name` будет существовать инстанс класса `String`, который сразу приобретает свойства строки, одним из которых является свойство `length`:
```javascript
var name = new String("BEViS");
console.log(name.length); // 5
```
Помните?

Так здесь тоже самое, только с другим свойством:
```javascript
function Input (params) {
    this.name = params.name;
    return this;
}

var inputLogin = new Input({name: 'login'});
console.log(inputLogin.name); // --> login
```

Мне нравится думать, что встроенный в `Javascript` класс `String` (да и все остальные) тоже описывается с помощью `function`, типа так:
```javascript
function String () {
    this.length = // здесь каким-то образом высчитывается длина строки;
    return this;
}
```

_Я уверен, что это не так. Кажется там всё написано на `C++` но мне нравится так думать — так мне понятнее._

Да, кстати, пора выучить новый ООП-термин. Функция, с помощью которой мы описывали  класс `Input` ещё называется функция-конструктор. Или просто конструктор. Потому что она как бы конструирует конкретные инстансы (в нашем случае - конкретный объект `inputLogin`). Этот термин нужно выучить, пользоваться им вы будете часто — даже если не в этой статье, то в жизни. Всё ООП-адепты употребляют его часто.

Итак, мы описали класс, создали от него объект, но добавить этот объект в дерево веб-страницы пока не можем. Потому что объект не представлен никаким тегом. Давайте сделаем наш класс полезным, чтобы он делал то же самое, что раньше мы делали в простыне функций.

```javascript
function Input (params) {
    this.domElement = document.createElement('input');
    this.domElement.name = params.namуAttr;

    return this;
}

var inputLogin = new Input({namуAttr: 'login'});
document.body.appendChild(inputLogin.domElement);
```

Разберем этот код.

- Я вызвал конструктор класса `Input` с помощью оператора `new Input({namуAttr: 'login'})`.
- Конструктор - это обычная `js`-функция, которая умеет принимать параметры. Ну, я туда и передал параметр в виде хеша `{namуAttr: 'login'}`
- Внутри конструктора я создал новое поле класса `this.domElement` и в него сохранил результат выполнения встроенного в `document` метода `createElement`. Останавливаться на этом методе не надо, верно? Вы и так про него знаете?
- Метод `createElement` возвращает объект класса `HTMLElement`. О, да, это ещё один встроенный в браузер Класс.
- Полученный объект класса `HTMLElement` мы сохраняем в поле `this.domElement` класса `Input`.
- А следующей строкой устанавливаем ему свойство `this.domElement.name`. Оказывается, у объектов класса `HTMLElement` есть своё собственное поле `name`, в которое мы можем передать значение. Этим и занимаемся - принимаем значение из параметра `params` функции-конструктора (нам приходит хеш с одним ключом `namуAttr`).
- И последнее, что делает конструктор - возвращает `this`. Куда? В переменную `inputLogin`.

_Получается, что в переменной `inputLogin` хранится инстанс класса `Input`. А у этого инстанса есть только одно 
собственное поле - `domElement`, которое хранит в себе инстанс класса `HTMLElement`. А у этого инстанса мы поменяли его собственное поле `name` в значение 'login'._

- И потом мы делаем `appendChild` — внутрь `document.body` "аппендим" фактически инстанс класса `HTMLElement`. Браузер знает про класс `HTMLElement` всё, и умеет его рендерить в html-тег.  

В результате внутри тега `body` возникает тег `<input name="login">`.

Зачем всё это надо?! Что-то наворотили-наворотили... На кой черт так сложно?!

Я смогу ответить на это недовольство, но ниже. Чтобы влюбиться в ООП на `Javascript` нужно узнать ещё совсем чуть-чуть. Совсем немного. А именно - как создавать методы класса. То есть, говоря про машину, как программировать умения автомобиля.

Читаем дальше, учимся? Или бросим всю эту ерунду — будем программировать по старинке процедурным способом?

Кстати, почему же я выше сказал, что не существует _красивого_ способа описывать свои собственные классы в `Javascript`? Почему я так сказал? Вот смотрю я на функцию-конструктор и мне всё нравится - ладненькая такая функция, аккуратненькая, понятная. Что не так?

```javascript
function Input (params) {
    this.domElement = document.createElement('input');
    this.domElement.name = params.namуAttr;

    return this;
}

var inputLogin = new Input({namуAttr: 'login'});
```

Всё-таки читаем дальше и учимся, да? ;)

Отлично.

Не существует красивого _нативного_ способа описывать методы класса. До сих пор мы описывали свойства объектов, то есть поля. А как запрограммировать поведение - не обсуждали? Машина должна уметь двигаться и останавливаться. Инпут должен уметь реагировать на установку фокуса и нажатие двух клавиш на клавиатуре. Как реализовать это поведение внутри класса `Input`? И что очень важно отметить, как реализовать это внутри класса `Input` _нативным для `javascript`_ образом?

Ответ, который пугает каждого неопытного `js`-программиста, звучит сурово: "Через прототипы".

### Методы класса. Prototype

Это суровый ответ, потому что понять, что такое прототипы непросто. Это настолько чужеродное для человеческой культуры изобретение, что понять его смысл получается далеко не сразу. И далеко не у всех из нас. К примеру, я совсем недавно понял эти ужасные прототипы, когда моя коллега из Яндекс.Карт приготовила внутренний семинар на тему "Прототипы в Javascript". Она сделала это специально, чтобы рассказать о прототипах так просто, чтобы понял даже школьник. Школьников на её семинаре не было, а я был. И я понял. Спасибо тебе, Олеся!

И сейчас я вам расскажу очень понятно. Слушайте внимательно.

**Прототипы в Javascript - это... вообще не важно что**. Вообще! Вам не нужно задумываться, что это такое и как они устроены.

_Если очень интересно, прочитайте у Ильи Кантора, он смог это объяснить [очень понятно](https://learn.javascript
.ru/prototype). Но лучше не надо, поберегите себя. Хотя бы сейчас. Прочитайте через пару недель. Или через пару-тройку месяцев._

Чтобы пользоваться прототипами совершенно не нужно понимать, что это такое. Я, к примеру, не разбираюсь в устройстве своего автомобиля. Но езжу на нём каждый день. И с прототипами можно поступить так же.

Прототипы вы будете использовать для двух вещей:

1. Чтобы описывать методы ваших Классов.

2. Чтобы наследовать один ваш Класс от другого вашего Класса.

Всё! 

Как и почему это работает, — пожалуйста, – не задумывайтесь сейчас. Оно вам точно не надо. Пока не надо.

Созадим-ка лучше метод у класса `Input`:

```javascript
function Input (params) {
    this.domElement = document.createElement('input');
    this.domElement.name = params.namуAttr;

    return this;
}

Input.prototype.onFocused = function (e) {
    e.target.style.border = '1px solid yellow';
};
```

Чтобы в класс добавить метод, его нужно объявить не у самого класса, а у какого-то его служебного поля по имени 
`prototype`. Это самый правильный нативный способ добавлять методы в класс.

Почему это способ я называю некрасивым? Потому что хочется обходиться без всяких прототипов. Знаете, как хочется? К примеру очень хочется так:
```javascript
function Input (params) {
    this.domElement = document.createElement('input');
    this.domElement.name = params.namуAttr;

    this.onFocused = function (e) {
         e.target.style.border = '1px solid yellow';
    };

    return this;
}
```

И знаете, что? Так тоже можно. И это даже называют функциональным стилем программирования `javascript`-классов. Но я 
не рекомендую им пользоваться. Давным-давно, когда я только учился `ООП` на `Javascript`, я создавал классы таким 
образом и... мучался с ними. И вы намучаетесь, если будете описывать классы таким образом.

_Дело в том, что такой стиль рождает дополнительные трудности, которые приходится решать ещё более некрасивыми способами: всякими `call(this)` при каждом вызове методов класса или `bind(this)` для каждого описания метода класса . Об этом хорошо рассказал Илья в статье про [функциональное наследование](https://learn.javascript.ru/functional-inheritance), спасибо ему. Прочтите обязательно, только не сейчас. Потом можно ещё прочитать [сравнение функционального и прототипного способов](https://learn.javascript.ru/classes#сравнение), для полноты картины, так сказать._

Сейчас просто поверьте. Прототипный лучше :)

Итак, допилим наш класс, чтобы метод класса работал:
```javascript
function Input (params) {
    this.domElement = document.createElement('input');
    this.domElement.name = params.namуAttr;

    // Подписываемся на событие `focus` на инпуте
    // Когда на элементе сработает фокус, вызови наш собственный обработчик.
    this.domElement.addEventListener('focus', this.onFocused);

    return this;
}

Input.prototype.onFocused = function (e) {
    e.target.style.border = '1px solid yellow';
};

var inputLogin = new Input({namуAttr: 'login'});
document.body.appendChild(inputLogin.domElement);
```

Если этот код проверить в браузере, внутри тега `body` появится тег `input`. Мы его увидим в окне браузера. А если ткнём мышкой в этот инпут, то браузер создаст на инпуте событие `focus`. А так как мы в конструкторе класса подписались слушать событие `focus` на инпуте, то вызовется собственный метод `this.onFocused`, который мы описали через `Input.prototype.onFocused`.

Добавим ещё один обработчик - будем слушать кейап на инпуте. И можно добавить метод, с помощью которого инстанс класса будет сам себя рендерить внутри какого-то `html`-элемента, в нашем примере внутри `document.body`. И тогда нам не придётся каждый инстанс добавлять в дерево — он будет это делать сам из своего конструктора.
```javascript
function Input (params) {
    this.domElement = document.createElement('input');
    this.domElement.name = params.namуAttr;

    // Подписываемся на событие `focus` на инпуте
    // Когда на элементе сработает фокус, вызови наш собственный обработчик.
    this.domElement.addEventListener('focus', this.onFocused);

    // Подписываемся на событие `keyup` на инпуте
    // Когда пользователь нажмёт клавишу на клавиатуре, стоя курсором внутри инпута, вызови наш собственный обработчик.
    this.domElement.addEventListener('keyup', this.onKeyUpped);

    // Рендерим инпут на странице
    this.render();

    return this;
}

Input.prototype.onKeyUpped = function (e) {
    if (e.keyCode === 13) {
        // Нажали Enter
        console.log(e.target.value);
    } else if (e.keyCode === 27) {
        // Нажали ESC
        e.target.value = '';
    }
};

Input.prototype.onFocused = function (e) {
    e.target.style.border = '1px solid yellow';
};

Input.prototype.render = function () {
    document.body.appendChild(this.domElement);
};

var inputLogin = new Input({namуAttr: 'login'});
```

Всё. Теперь вы знаете всё, чтобы самому описывать собственные классы и создавать от них объекты. 

Посмотрим и сравним оба стиля программирования в одной таблице:

<table>   
<tr>
    <th>Процедурный стиль</th>
    <th>Объектно-ориентированный стиль</th>
</tr>
<tr>
   <td style="vertical-align: top;">
<pre>
var inputLogin = $('&lt;input type="text" name="login"&gt;').appendTo('body');
var inputEmail = $('&lt;input type="text" name="email"&gt;').appendTo('body');
var inputAge = $('&lt;input type="text" name="age"&gt;').appendTo('body');

inputLogin.focus(onInputFocused);
inputEmail.focus(onInputFocused);
inputAge.focus(onInputFocused);

inputLogin.keyup(onInputKeyUpped);
inputEmail.keyup(onInputKeyUpped);
inputAge.keyup(onInputKeyUpped);

function onInputFocused (e) {
    e.target.css('border', '1px solid yellow');
}

function onInputKeyUpped (e) {
    if (e.keyCode === 13) {
        console.log(e.target.value);
    } else if (e.keyCode === 27) {
        e.target.value = '';
    }
}
</pre>
   </td>
   <td style="vertical-align: top;">
<pre>
function Input (params) {
    this.domElement = document.createElement('input');
    this.domElement.name = params.namуAttr;

    this.domElement.addEventListener('focus', this.onFocused);
    this.domElement.addEventListener('keyup', this.onKeyUpped);

    this.render();

    return this;
}

Input.prototype.onKeyUpped = function (e) {
    if (e.keyCode === 13) {
        console.log(e.target.value);
    } else if (e.keyCode === 27) {
        e.target.value = '';
    }
};

Input.prototype.onFocused = function (e) {
    e.target.style.border = '1px solid yellow';
};

Input.prototype.render = function () {
    document.body.appendChild(this.domElement);
};

var inputLogin = new Input({namуAttr: 'login'});
var inputEmail = new Input({namуAttr: 'email'});
var inputAge = new Input({namуAttr: 'age'});
</pre>
   </td>
</tr>   
</table>   

В чём главное преимущество ООП перед продурным стилем? В том, что все свойства и умения конкретного объекта мы 
описываем внутри самого объекта. В том, что каждый объект, инстанцированный от конкрентного класса гарантированно 
будет обладать всеми свойствами и умениями этого класса. В том, что код сайта больше не похож на спагетти из 
разношерстных функций, которые вызывают одна другую не-пойми-в-какой последовательности. Отныне ваш код — это 
объекты, наполненные смыслом и достоинством. А вы, программист такого сайта, — единовластный хозяин этих объектов, — 
только вы один решаете, какие объекты (и классы) создавать, и как они будут взаимодействовать в вашем скрипте. 

Эту идеальную картину омрачает единственный мазок — нативно `ООП` на `Javascript` реализуется с помощью 
малопонятного и, прямо скажем, нелицеприятного свойства `prototype`. Но знаете, что? Оказывается можно создавать 
объекты красиво, хоть и не нативно. Вам понравится, обещаю. Но об этом через 2 минуты, а пока подведем итоги тому, 
что мы узнали. 

### Что мы узнали?

Классы - это нечто вроде правил, по которым создаются объекты определенного типа. Можно думать, что классы - это вспомогательные шаблоны, что ли. Сами по себе они бессмысленны, нужны для того, чтобы давать жизнь конкретным объектам.

Объект класса, он же объект какого-то типа (как мы его раньше называли) - это специальным образом организованный код. Если раньше мы организовывали свой код преимущественно в функции, то теперь мы предпочитаем организовывать код в некие объекты, которые обладают некими свойствами и умениями, называемыми соответсвенно полями и методами объекта. Такой объект, произведенный от конкретного класса принято называть инстансом этого класса, или экземпляром, кому как нравится.

В `Javascript`-е есть встроенные классы, и мы создавали от них инстансы, не подозревая, что мы это делаем.
Когда мы создавали строковую переменную - мы как бы создавали инстанс класса String.
Когда мы создали массив — мы на самом деле создавали инстанс класса Array.

Но встроенных классов нам мало. Нам хочется уметь создавать свои собственные классы объектов, потому что мы немного 
устали от процедурного стиля программирования, когда мы огранизуем код с помощью функций, и они вызывают друга друга
 в каком-то порядке, который довольно скоро становится  хаотическим, плохо управляемым, нерасширяемым.

ООП - это способ разделения нашего кода на классы и порождённые ими объекты. Во всех больших языках, вроде `Java` 
или `C#` объектно-ориентированный подход программирвоания "встроен" по умолчанию. Мы хотим принести его в 
`javascript` и, к счастью, такая возможность есть.

Создать экземпляр класса очень просто. Это делает оператор `new`. Описать сам класс тоже просто, хоть и не очень 
красиво. Для этого используется, как ни странно, обычная функция, которая обязательно должна вернуть ключевое слово 
`this`.

Внутри этой функции, её ещё называют конструктором класса, мы можем объявить все свойства будущих объектов, будущих 
инстансов, которые мы будем создавать оператором `new`. Свойства объявляются с помощью полей вида `this.something`.

А вот умения класса, а значит и умения каждого инстанцированного от этого класса объекта, мы описываем не в 
функции-конструкторе, а в отдельных методах, которые сохраняем в специальном и непонятном поле `prototype`. То есть,
 у каждого конструктора обязательно есть такое служебное поле по имени `prototype`. И именно в нём мы описываем 
 методы класса. Почему так придумано в `Javascript` - это отдельная тема, не скажу, что тема проста для понимания, 
 её можно изучить сильно позже, или не изучать вообще. 
 
Дальше мы будем говорить с вами о капсулирования информации в объектах, о наследовании, о способах общения объектов 
друг с другом. Но прежде всего мы поговорим о том, как же обойтись без уродующих наш код прототипов. Ну, ужас же! 
 
## Библиотека `inherit`.

Всех `js`-программистов не устраивает ситуация с `prototype`. Конечно, возможно среди нас есть такие, кто любит каждое 
объявление метода присваивать классу через его прототип. Не знаю, может и есть. Но вообще-то ООП-программисты - народ, 
исповедующий красоту в коде. А в прототипах нет ни грамма красоты. Поэтому ООП-программисты придумали 
решение, которое в общем виде выглядит, как функция, которая работает с прототипами сама. А мы лишь описываем 
классы так красиво, как нам хочется. 

Помните, как нам хотелось бы это делать? Я показывал выше код и говорил, что _так_ красиво, только рождает 
проблемы:
```javascript
function Input (params) {
    this.myProperty = params.value;

    this.myMethod = function () {
        console.log(this.myProperty);
    };

    return this;
}
```

То есть, хочется, чтобы класс описывался в одном цельном фрагменте кода, без распыления на объявления методов через 
прототипы.

А вот как выглядит ровно этот же код с помощью специализированной функции `inherit`:
```javascript
var Input = inherit({
    __constructor: function (params) {
        this.myProperty = params.value;
    },

    myMethod: function () {
        console.log(this.myProperty);
    },
});
```

Инстанцироваться от него точно так же, как и раньше: `var inputLogin = new Input();`. 

И вот каким красивым и понятным становится наш пример уже с использованием функции `inherit`:
```javascript
var Input = inherit({
    __constructor: function (params) {
        this.domElement = document.createElement('input');
        this.domElement.name = params.namуAttr;
    
        this.domElement.addEventListener('focus', this.onFocused);
        this.domElement.addEventListener('keyup', this.onKeyUpped);
    
        this.render();
    },

    onKeyUpped: function (e) {
        if (e.keyCode === 13) {
            console.log(e.target.value);
        } else if (e.keyCode === 27) {
            e.target.value = '';
        }
    },
    
    onFocused: function (e) {
        e.target.style.border = '1px solid yellow';
    },
    
    render: function () {
        document.body.appendChild(this.domElement);
    }
});

var inputLogin = new Input({namуAttr: 'login'});
var inputEmail = new Input({namуAttr: 'email'});
var inputAge = new Input({namуAttr: 'age'});
```

Никаких тебе прототипов, весь класс `Input` описывается одним логически понятном фрагментом кода. Красота.

Эту функцию придумал и создал наш коллега из Яндекса, — Дмитрий Филатов, — вот 
[репозиторий этого проекта](https://github.com/dfilatov/inherit). Почему функция называется именно `inherit` и 
что она умеет делать ещё, мы поговорим ниже. А сейчас минутка признательности. 

_Дима, спасибо тебе большое!_
_Именно благодаря твоему решению я полюбил программирование в объектно-ориентированом стиле на `Javascript`._

В скором будущем в `Javascript` можно будет создавать классы нативно и красиво одновременно. Заглянем в будущее на 
мгновение и увидим, как мы перепишем наш класс, когда все барузеры поддержат новый стандарт `Javascript` — 
`ECMAScript 2015 (ES6)`:

<table>
<tr>
    <th>Настоящее: с помощью `inherit`</th>
    <th>Будущее: `ECMAScript 2015 (ES6)`</th>
</tr>
<tr>
   <td style="vertical-align: top;">
<pre>
var Input = inherit({
    __constructor: function (params) {
        this.domElement = document.createElement('input');
        this.domElement.name = params.namуAttr;
    
        this.domElement.addEventListener('focus', this.onFocused);
        this.domElement.addEventListener('keyup', this.onKeyUpped);
    
        this.render();
    },

    onKeyUpped: function (e) {
        if (e.keyCode === 13) {
            console.log(e.target.value);
        } else if (e.keyCode === 27) {
            e.target.value = '';
        }
    },
    
    onFocused: function (e) {
        e.target.style.border = '1px solid yellow';
    },
    
    render: function () {
        document.body.appendChild(this.domElement);
    }
});
</pre>
    </td>
   <td style="vertical-align: top;">
<pre>
class Input {
    constructor: function (params) {
        this.domElement = document.createElement('input');
        this.domElement.name = params.namуAttr;
    
        this.domElement.addEventListener('focus', this.onFocused);
        this.domElement.addEventListener('keyup', this.onKeyUpped);
    
        this.render();
    },

    onKeyUpped: function (e) {
        if (e.keyCode === 13) {
            console.log(e.target.value);
        } else if (e.keyCode === 27) {
            e.target.value = '';
        }
    },
    
    onFocused: function (e) {
        e.target.style.border = '1px solid yellow';
    },
    
    render: function () {
        document.body.appendChild(this.domElement);
    }
}
</pre>
    </td>
</tr>
</table>

В будущем нам придётся совсем немного переписать наш код, чтобы он работал с нативными классами. А пока будущее не 
наступило, мы будем пользовать функцией-хелпером `inherit`. Дима, спасибо тебе большое.





----

Если очень хочется, можно даже вызвать эти методы прямо от него:
```javascript
var inputLogin = new Input({namуAttr: 'login'});
document.body.appendChild(inputLogin.domElement);

inputLogin.onFocused();
```

Конечно, возникнет ошибка. Понятно же, почему? Потому что метод `onFocused` ожидает внутрь себя параметр `e`, то есть `Event`, `Событие`. Да, в пароаметр приходит инстанс ещё одного класса - класса `Event`.

_О, ещё один втроенный класс в `Javascript` ;)_

Но вообще-то эти методы не предназначены для публичного использования. Они должны бить приватными для объекта. "Приватными" означает, что никто не должен вызывать их напрямую. ООП-программисты договорились между собой, что приватные методы будем называть с нижним подчеркиванием впереди. И ещё договорились, что если метод приватный - его вызывать не может никто снаружи, только внутри.

Ох, представляю, что у вас сейчас вспухла голова. "Снаружи, внутри". Это ещё о чём вообще? Обещал, что будет всё просто и понятно, а в голове уже такая каша!

Я представляю :)

Поэтому мы с вами немного притормозим и закрепим всё, что уже узнали.

----

А теперь давайте прочитаем статью Илья Кантора. ""Про снаружи внутри""



----

_Итого, в ООП используется всего две сущности: `Класс` и `Объект класса` (он же `экземпляр` класса, он же `инстанс` класса)._
