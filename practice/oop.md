# ООП. Объектно-ориентированное программирование

`ООП` - это не что-то магическое и доступное только гениям программирования. Даже школьник, который по информатике 
не вылезает из троек, способен понять, что такое `ООП`, потому что объектно-ориентированное программирование — это лишь
 _ещё один_ способ организации своего кода. Всё! 
 
`ООП` - это когда вы пишете свой `javascript`-код не в виде плоского списка функций, а в виде так называемых 
`Классов` и `Объектов`. Непонятно, согласен :)

В классических учебниках эту тему пытаются объяснять на примере автомобиля.

Мол, автомобиль - это класс объектов. Если выражаться привычными нам словами, это категория объектов. Эта категория (класс) имеет характерные признаки - 4 колеса, двигатель, салон для пассажиров. Автомобили умеют двигаться в пространстве и перевозить людей. И там, в учебниках, утверждается, мол, **все** автомобили имеют **все эти** характерные признаки, а например, лифты не имеют **всех этих** признаков, а имеют какие-то свои признаки, значит они принадлежат к другому классу объектов.

А объект — это, мол, конкретная машина, созданная на конкретном автомобильном заводе. Она имеет все характерные признаки класса автомобиль (4 колеса, двигатель, салон...), но это уже не абстрактный класс (не абстрактная категория автомобилей), а вполне себе реальная штуковина, которую можно пощупать, в неё можно сесть, завести и поехать на море.

То есть класс, объясняли в учебнике, - это сущность абстрактная, шаблонная, она лишь описывает признаки (или правила), по которым нужно создавать конкретный экземпляр. Экземпляр класса. Или другими словами, объект класса. А вот объект - это уже  конкретная реализация этого класса.

Я когда читал эти объяснения в учебнике, я всё понимал. Про автомобили - всё понимал. Про `ООП` в `Javascript` - 
ничего не понимал. Как знания про автомобили применить к моим программам? Непонятно. 

Попыток объяснить эту тему существует множество — их легко найти в учебниках про настоящие объектно-ориентированные 
языки, среди которых на слуху `Java` и `C#`. Сейчас эти попытки можно обнаружить и в учебниках про `Javascript`. Но 
я всё же собираюсь предпринять свою собственную, потому что меня не устраивают объяснения всех этих бесспорно 
уважаемых людей. Я вам объясню эту тему так, как собираюсь объяснять её своей дочери годика эдак через четыре. То 
есть, понятно. И не про автомобили и лифты, а именно про `Javascript`.

## Что нужно знать?

К тому моменту, когда дочь будет готова воспринимать эту тему, она должна будет понимать, что такое переменные, какие типы переменных существуют в `javascript`, какие методы существуют у встроенных типов (например, у строк, у чисел, у массивов). Дочь должна уметь создавать функции, уметь их вызывать и принимать от них результаты.

Если всей этой базы не понимать, задаваться вопросом, что такое объектно-ориентированное программирование, совершенно незачем. ООП - это абстракция над базовыми возможностями `javascript`. Если не знать базовых возможностей, глупо лезть в дебри.

Я предполагаю, что вы прекрасно разбираетесь в основах. Поэтому вперёд.

## Вообще-то, вы умеете писать объектно-оринтированный код!

Конечно же! Не ослышались. И хотя даже школьник-троеничник знает, что `Javascript` вообще ни разу не 
объектно-ориентированный язык, вам следует знать, что когда вы пишете `javascript`-программу, вы чуть ли не в 
каждой строчке своего кода создаёте `Объекты` из `Классов` и оперируете ими мастерски, только не осознаёте этого. 

Каждый из нас _уже умеет_ писать объектно-ориентированные программы.

```javascript
var name = 'BEViS';
```
Что в этом коде происходит? Ничего  магического, скажете вы. Ну, создаём переменную `name` строкового типа и присваиваем
 ей значение 'BEViS'. Вам этот оператор  совершенно понятен. Ну, переменная. Ну, строкового типа. Ну и?

На самом деле, этот же оператор может быть записан иначе. Вы это наверняка знаете. Или знали раньше, но забыли:
```javascript
var name = new String('BEViS');
```
Этот код совершенно идентичен предыдущему. Но я попробую предположить, что разработчики `Javascript` пожалели нас, 
бедных, и дали нам возможность писать это же короче - без вызова оператора `new` и без указания типа `String`. 
Спасибо им. Но что такое `new String()`? Посмотрим на два фрагмента кода и сравним комментарии к ним: 

```javascript
// Создаём переменную `name` строкового типа и присваиваем ей значение
var name = 'BEViS';
```

```javascript
// Создаём объект `name` строкового класса и присваиваем объекту значение
var name = new String("BEViS");
```

То есть вместо слова `переменная` можно смело говорить слово `объект`. А вместо слова `тип` можно смело говорить 
слово `класс`.

Вы так не говорили никогда, я тоже так никогда не говорил — так говорить нас не учили ни в одном учебнике. Но если мы
  хотим научиться писать объектно-ориентированные программы, нужно нуачиться смотреть на свои уже написанные программы 
  под новым углом. Мне кажется, если вы представите, что любая переменная, которую вы создавали в своей жизни, на самом 
  деле никакая не переменная, а `Объект` какого-то `Класса`, понять всё остальное про `ООП` будет легко. Попробуйте 
  вместе со мной относиться к переменным именно так. Договорились, пробуем?

Когда вы создаёте строковую переменную, на самом деле вы создаёте объект строкового класса. Или "экземпляр класса 
String". Замысловато звучит, чужеродно даже. Но так принято, все ООП-адепты выражаются именно такими словами и другу
 друга понимают. И мы привыкнем, и мы научимся.

Повторяем и запоминаем. Когда мы пишем `var name = 'BEViS'`, на самом деле мы создаём не строковую переменную, а 
экземпляр класса `Строка`. Или, другими словами, объект класса `String`.

В учебниках про `javascript` вы на первых же страницах встречаете информацию о встроенных типах данных. Вы, 
конечно, их помните:
- String
- Number
- Boolean
- ...

Давайте перестанем думать о них, как о **типах** данных, а будем относиться к ним, как к **классам** данных.

_Правильно это с академической точки зрения или нет, я уверен, вообще не важно. Я хочу, чтобы вы осознали прямо сейчас — вы каждый день пишете программы с использованием классов и объектов, только не называете их этими словами. Как только вы это осознаете, вы легко поймёте, как создавать и как пользоваться своими собственные классами и объектами. Но про свои классы и объекты чуть позже. А пока начнём привыкать к новым словам._

Как любая реальная машина имеет 4 колеса, двигатель и салон, так и любой объект, созданный из класса `String` имеет имеет свой характерный набор признаков. Это же понятно, да?

```javascript
var name = new String("BEViS");
console.log(name.length); // 5
```

Мы только что создали объект `name`, и у него вдруг появляется свойство `length`, хотя мы такое свойство не определяли. Оно появилось само собой. Откуда? Вы прекрасно знаете, что любая строковая переменная обладает таким свойством, эка невидаль. Но давайте подумаем об этом по-новому. Покатайте в уме такое объяснение: любой экземпляр класса `String` обладает свойством `length`. Как только мы создали новый экземпляр класса с помощью оператора `var name = new String('BEViS')` (или с помощью шотката `var name = 'BEViS'`, что одно и то же ) и сохранили его в объекте `name`, созданный объект приобрел сразу все характерные признаки класса `String`.

 У любой строки есть такая вещь, как длина строки. Это признак строки? Признак, конечно. А есть ли такой признак у 
 числа? Правильнее было бы задать этот вопрос другими словами: "А есть ли точно такой же признак у объекта, 
 созданного от класса `Number`"? Нет.

 Доказываю. Создаём объект класса `Number` и спрашиваем у него длину:
```javascript
var age = new Number(36);
console.log(age.length); // undefined
```
Нет такого свойства у экземпляра класса `Number`. Да вы и сами это знаете, только никогда не рассуждали об этом словами `Класс` и `Объект`.

На заводе конкретную машину делают по правилам класса "Автомобиль". А в программах на `js` мы создаём строковые, 
числовые и булевские переменные с помощью встроенных в `Javascript` классов `String`, `Number`, `Boolean`. Это так 
называемые примитивные ~~типы~~ классы данных. Но есть и более сложные ~~типы~~ классы, вы ими пользовались 
множество раз:
```javascript
var data = [];
```

`[]` — это тоже шоткат для нашего удобства. На самом деле полная запись выглядит так:
```javascript
var data = new Array();
```
То есть ~~переменная~~ объект `data` — это экземпляр ~~типа~~ класса `Array`.


Теперь вы поняли, что в своих `Javasсript`-программах вы **всё время** создавали объекты из классов? Вы этим занимались 
всю свою жизнь, только не осознавали этого.

Чтобы окончательно убедить вас в этом, последний довод.

Вы когда-нибудь генерили картинки налету и вставляли в `DOM`? Конечно. Не таким ли образом вы это делали?
```javascript
var logo = new Image();
logo.src = "picture-of-your-company.jpg";
logo.alt = "Company's Logotype";
logo.title = "Изготовление сайтов под ключ";
document.body.appendChild(logo);
```

Этих 4-х строк достаточно, чтобы в теге `body` появился новый тег
```html
<img src="picture-of-your-company.jpg" alt="Company's Logotype" title="Изготовление сайтов под ключ">
```

В результате
- мы увидим на странице изображение, реализованное тегом `img`.
- браузер навесит на изображение какие-то дефолтные `CSS`-стили.
- снабдит изображение своим собственным особенным поведением:
  - если вдруг картинка по `HTTP` не подгрузится, на её месте браузер покажет текст "Company's Logotype"
  - а если пользователь подведет курсор мыши к картинке, браузер покажет всплывающий тултип с текстом "Изготовление сайтов под ключ"".

Для вас это вообще не новость. Но задумайтесь — мы написали один простой оператор `new Image()` и получили объект, который обладает сразу и  `HTML`-разметкой, и `CSS`-стилями и интерактивным поведением. Получается, что в браузер встроен класс объектов `Image`. Когда мы написали оператор `new Image()`, мы создали экземпляр класса `Image`.

_Кстати, экземпляр класса ещё называют инстансом класса от англ. ["instance"](https://translate.yandex.ru/?text=%D1%8D%D0%BA%D0%B7%D0%B5%D0%BC%D0%BF%D0%BB%D1%8F%D1%80&lang=ru-en)._

Это и называется `Объектно-Ориентированное Программирование`.

Ах, как жаль, что таких встроенных в браузер классов очень мало. Почему нет класса `Input`, `Button`, `Form`? Как было бы легко программировать веб-сайты, если бы таких классов было много и сразу. Но их нет. Это минус. Зато их можно создавать самим, и это плюс. Цель этого туториала — показать вам, что создавать свои собственные классы - это очень просто. Программировать в ООП-стиле на `Javascript` - это просто и удобно.

Попробовав это один раз, вы влюбитесь в ООП-стиль и будете удивляться, как же вы программировали раньше без ООП?

Подводём быстрые итоги.

В `Javascript` мы всё время оперируем не просто переменными (как мы всегда думали), а исключительно конкретными инстансами классов. Создаём ли мы строковую переменную или чисельную, или логическую, или массив, или функцию(!), или картинку — на самом деле мы создаём экземпляры соответствующих классов `String`, `Number`, `Boolean`, `Array`, `Function` или `Image`. Вы делали это в каждой программе. Вы умеете это делать в совершенстве.

Только вы использовали _уже существующие_ в `Javascript` классы. А теперь нам хочется уметь создавать свои собственные классы, чтобы сделать код ещё более удобным.

## Как мы программируем по-старинке

Начинающие веб-программисты думают про `web`-страницы, как про набор `html`-тегов. Например, элементы формы 
"текстовое поле" - это тег `<input type="text">`. Как на странице может появиться такой тег?

1. Сервер может построить `html` страницы и отдать в браузер. И в этой `html`-ке где-то внутри `body` уже будет такой 
тег.
2. Мы можем на стороне браузера сгенерить такой тег в клиентском `js`.

Серверную генерацию рассматривать не будем, это скучно. Хочется веселья. Как мы можем сгенерить инпут налету?
```javascript
var myInput = document.createElement('input');
myInput.type = 'text';
document.body.appendChild(myInput);
```

Или можно с помощью jQuery:
```javascript
var myInput = $('<input type="text">');
myInput.appendTo('body');
```

В обоих случаях внутри тега `body` появится новый тег `input`.

Нам хочется, чтобы этот инпут взаимодействовал с пользователем.  Например:

1. Если пользователь поставил курсор в поле, обвести поле фокусной рамкой нужного цвета.

2. Если поле находится в фокусе, и пользователь ввел какой-то текст в поле, а затем нажал кнопку `ESC`, очистить поле от введенного значения.

3. Если поле находится в фокусе, и пользователь нажал кнопку `Enter`, вывести введенное значение в консоль браузера.

Такого поведения браузер не обеспечил для вновь созданного инпута. Значит это должны сделать мы. Предположим, что вы
 не используете `jQuery`, а предпочитаете программировать на кристалльно-чистом и бесконечно-прекрасном `Javascript` 
 без всяких сторонних библиотек. Тогда ваш код будет выглядеть приблизительно так:

```javascript
// Создаём инпут
var myInput = document.createElement('input');
myInput.type = 'text';

// Добавляем в DOM
document.body.appendChild(myInput);

// Подписываемся на событие `focus` на инпуте
// Когда на элементе сработает фокус, вызови наш собственный обработчик.
myInput.addEventListener('focus', onInputFocused);

// Подписываемся на событие `keyup` на инпуте
myInput.addEventListener('keyup', onInputKeyUpped);

// Описываем обработчик фокуса
function onInputFocused (e) {
    e.target.style.border = '1px solid yellow';
}

// Описываем обработчик нажатия на клавиши клавиатуры
function onInputKeyUpped (e) {
    if (e.keyCode === 13) {

        // Нажали Enter
        console.log(e.target.value);

    } else if (e.keyCode === 27) {

      // Нажали ESC
      e.target.value = '';

    }
}
```

Возможно, я допустил ошибки. Скорее всего, этот код можно оптимизировать. Не сомневаюсь, вы напишете его лучше.

Но я не об этом. Давайте подумаем, где этот код мы пишем? Я предполагаю, что у вас есть какой-то `page.js` файл, в 
котором вы пишете всю программу. Этот `page.js` подключается на веб-страницу с помощью тега `<script src='page
.js'></script>`. И вы представляете себе очень хорошо, что когда этот файл загрузится в память браузера, запустится 
интерпретатор языка `Javascript`, который будет читать каждую строку в вашем файле `page.js` сверху вниз и выполнять
 одну за другой. По-строчно, одну за одной.  В какой-то момент интерпретатор дойдёт до строк, где мы создаём инпут и
  навешиваем на него обработчики событий. Выполнит операторы в этих строках и пойдёт дальше. С этим проблем нет. Это
   вы понимаете. А что тут не понять, спросите вы?

У меня один вопрос. А если мы создаём не один инпут? Если мы должны создать два, три, четыре инпута. 
```html
<input type="text" name="login">
<input type="text" name="email">
<input type="text" name="age">
```

На что станет похож наш код? А я вам покажу:

```javascript
// Создаём три инпута
var inputLogin = document.createElement('input');
inputLogin.type = 'text';
inputLogin.name = 'login';

var inputEmail = document.createElement('input');
inputEmail.type = 'text';
inputEmail.name = 'email';

var inputAge = document.createElement('input');
inputAge.type = 'text';
inputAge.name = 'age';

// Добавляем их в DOM
document.body.appendChild(inputLogin);
document.body.appendChild(inputEmail);
document.body.appendChild(inputAge);

// Слушаем событие focus на каждом инпуте
inputLogin.addEventListener('focus', onInputKeyUpped);
inputEmail.addEventListener('focus', onInputKeyUpped);
inputAge.addEventListener('focus', onInputKeyUpped);

// Слушаем событие keyup на каждом инпуте
inputLogin.addEventListener('keyup', onInputKeyUpped);
inputEmail.addEventListener('keyup', onInputKeyUpped);
inputAge.addEventListener('keyup', onInputKeyUpped);

// Описываем обработчик фокуса
function onInputFocused (e) {
    e.target.style.border = '1px solid yellow';
}

// Описываем обработчик нажатия на клавиши клавиатуры
function onInputKeyUpped (e) {
    if (e.keyCode === 13) {

        // Нажали Enter
        console.log(e.target.value);

    } else if (e.keyCode === 27) {

      // Нажали ESC
      e.target.value = '';

    }
}
```

Конечно, и этот код можно оптимизировать, с помощью нескольких `forEach`, например. Но даже так он останется 
некрасивым. Избыточным. А если нам не только инпуты создать надо, а ещё форму. А ещё шапку сайта. Или подвал. Или 
вообще все-все элементы на странице нам надо создавать налету? Создавая код по старинке, мы получим огромную 
простынь операторов. Интерпретатор `Javascript` жаловаться не будет, ему всё равно - он все прочитает и выполнит. Но
 ведь нам, людям, такой код читать и поддерживать трудно. Больно.

_Конечно, можно этот код разносить по нескольким файлам, а потом склеивать их в один `page.js` с помощью какого-то сборщика вроде `Grunt`, `Gulp` и т.п. Я вам так скажу - не только можно, а нужно. Необходимо! Этим вы хотя бы немного облегчите себе работу с этим кодом._

Но просто разносить такой код по отдельным файлам мало помогает.

Вот, если бы (давайте помечтаем вслух) в браузере уже существовал специальный класс `Input`? А в нём были бы описаны
 все нужные обработчики событий? Как бы мы тогда создали три инпута?

Наверное так:
```javascript
//  Создаём три инпута
var inputLogin = new Input({name: 'login'});
var inputEmail = new Input({name: 'email'});
var inputAge = new Input({name: 'age'});

// Добавляем в DOM
document.body.appendChild(inputLogin);
document.body.appendChild(inputEmail);
document.body.appendChild(inputAge);
```

Вставка в DOM никуда бы не делась. А вот описывать обработчики для каждого инпута нам  уже не нужно. _Было бы_ не нужно. Красота.

К счастью, мы можем такую красоту сделать сами.

## Создаём объекты из классов — оператор `new`

Об операторе `new` можно почитать в учебнике Ильи Кантора: [https://learn.javascript.ru/constructor-new](https://learn.javascript.ru/constructor-new). Прочитайте обязательно.

Но даже если не прочитали, вы уже поняли, что оператор `new` нужен для того, чтобы создать инстанс какого-то класса, экземпляр этого класса, конкретный объект класса. Что происходит под капотом этого оператора, прямо сейчас совершенно не важно знать. Важно понять одно - для создания инстансов класса в языке `Javascript` всё есть.

Чего в нём нет, так это _красивого_ способа описывать свои собственные Классы. Слово "красивого" я выделил курсивом не случайно. Нет именно красивого способа. А вообще-то такой способ есть. Он странный и чужеродный для понимания человеком, но он есть. И мы сейчас его изучим.

Раз уж браузер не обеспечил нас, разработчиков, классом `Input`, напишем его сами.

Напомню, создавать инстанс этого класса мы хотим так:
```javascript
var inputLogin = new Input({name: 'login'});
```

## Описываем свой класс с помощью `Function`

Вы прекрасно знаете, что такое функции. Вы создавали их так:
```javascript
function getValue () {
    // ...  
}
```

Или так:
```javascript
var getValue = function () {
    // ...  
}
```

А знаете, как описать класс `Input`? А вот как:
```javascript
function Input () {
    // ...

    return this;
}
```

Забавно, да? Любая функция может стать классом, если выполнить два условия — одно критичное, второе некритичное.

1. Имя функции должно начинаться с заглавной буквы. Это некритичное требование, это скорее неписаное соглашение, ему 
можно не следовать. Но лучше его всё-таки выполнять, чтобы вы сами могли отличить по именам, где простая функция, а где 
целый класс.

2. Функция должна вернуть ключевое слово `this`.

Вот как я опишу класс `Input` и создание объекта `inputLogin` из него:
```javascript
function Input (params) {
    this.name = params.name;
    return this;
}

var inputLogin = new Input({name: 'login'});
console.log(inputLogin.name); // --> login
```

Что произошло?

Я создал объект класса `Input` — создал инстанс (ещё говорят, инстанцию) класса. То есть я создал конкретный инпут. 
Да, этот инпут пока ничего не умеет - ни html для себя создавать, ни реагировать на действия пользователя — ничего. 
Всё, что он умеет - хранить в себе поле `name` и заполнять его данными, которые передали при инстанцировании класса 
`Input`.

Мудрено? :)

И тут мы вернемся с вами к классическому примеру с машинами. Самое время :)

Есть набор правил, по которым создают автомобили. Эти правила гласят, что у любого автомобиля есть набор неких свойств и неких умений.

Например, любой автомобиль должен иметь 4 колеса (обычно, у машин всё таки 4 колеса, хотя были попытки сделать и трёхколесные). У автомобиля должен быть двигатель. Руль. Двери. Салон для пассажиров. С точки зрения ООП эти свойства называются `полями` автомобиля.

Ещё автомобиль должен уметь двигаться. Должен уметь останавливаться. Двери должны уметь открываться и закрываться, чтобы в салон могли сесть пассажиры. С точки зрения ООП эти все умения называются `методами` автомобиля.

_То есть свойства объекта мы в ООП называем "полями", а умения объекта называем "методами". Почему такие названия, сейчас не важно. Просто  запомните: когда встретите слова "поле объекта" или "поле класса", вспоминайте свойства автомобиля. А когда встретите "метод объекта" или "метод класса", вспоминайте умения автомобиля._

Вернемся к нашему классу `Input` и созданному из него объекту `inputLogin`.
```javascript
function Input (params) {
    this.name = params.name;
    return this;
}

var inputLogin = new Input({name: 'login'});
console.log(inputLogin.name); // --> login
```

Как мы говорили, объект `inputLogin` ничего не умеет - у него нет никаких умений, нет никаких методов. Но у него есть своё собственное свойство, которое хранится в поле `name` и которое можно получить через конструкцию `inputLogin.name`. Откуда оно взялось?

Это понятно. Поле `name` описано в классе `Input`. Благодаря оператору `new Input` мы создали экземпляр класса, который автоматически приобрёл все свойства класса `Input`. У класса `Input` есть пока только одно единственное свойство, описанное в поле `this.name`. А потом класс `Input` возвращает `this`. Значит и у объекта `inputLogin` будет только оно одно. Но будет совершенно точно.

Вам это ничего не напоминает? В самом начале мы рассматривали пример с инстансами строки и числа. И мы говорили, что `var name = "BEViS"` — это то же самое, что `var name = new String("BEViS")`. Следовательно в переменной `name` будет существовать инстанс класса `String`, который сразу приобретает свойства строки, одним из которых является свойство `length`:
```javascript
var name = new String("BEViS");
console.log(name.length); // 5
```
Помните?

Так здесь тоже самое, только с другим свойством:
```javascript
function Input (params) {
    this.name = params.name;
    return this;
}

var inputLogin = new Input({name: 'login'});
console.log(inputLogin.name); // --> login
```

Мне нравится думать, что встроенный в `Javascript` класс `String` (да и все остальные) тоже описывается с помощью `function`, типа так:
```javascript
function String () {
    this.length = // здесь каким-то образом высчитывается длина строки;
    return this;
}
```

_Я уверен, что это не так. Кажется там всё написано на `C++` но мне нравится так думать — так мне понятнее._

Да, кстати, пора выучить новый ООП-термин. Функция, с помощью которой мы описывали  класс `Input` ещё называется функция-конструктор. Или просто конструктор. Потому что она как бы конструирует конкретные инстансы (в нашем случае - конкретный объект `inputLogin`). Этот термин нужно выучить, пользоваться им вы будете часто — даже если не в этой статье, то в жизни. Всё ООП-адепты употребляют его часто.

Итак, мы описали класс, создали от него объект, но добавить этот объект в дерево веб-страницы пока не можем. Потому что объект не представлен никаким тегом. Давайте сделаем наш класс полезным, чтобы он делал то же самое, что раньше мы делали в простыне функций.

```javascript
function Input (params) {
    this.domElement = document.createElement('input');
    this.domElement.name = params.namуAttr;

    return this;
}

var inputLogin = new Input({namуAttr: 'login'});
document.body.appendChild(inputLogin.domElement);
```

Разберем этот код.

- Я вызвал конструктор класса `Input` с помощью оператора `new Input({namуAttr: 'login'})`.
- Конструктор - это обычная `js`-функция, которая умеет принимать параметры. Ну, я туда и передал параметр в виде хеша `{namуAttr: 'login'}`
- Внутри конструктора я создал новое поле класса `this.domElement` и в него сохранил результат выполнения встроенного в `document` метода `createElement`. Останавливаться на этом методе не надо, верно? Вы и так про него знаете?
- Метод `createElement` возвращает объект класса `HTMLElement`. О, да, это ещё один встроенный в браузер Класс.
- Полученный объект класса `HTMLElement` мы сохраняем в поле `this.domElement` класса `Input`.
- А следующей строкой устанавливаем ему свойство `this.domElement.name`. Оказывается, у объектов класса `HTMLElement` есть своё собственное поле `name`, в которое мы можем передать значение. Этим и занимаемся - принимаем значение из параметра `params` функции-конструктора (нам приходит хеш с одним ключом `namуAttr`).
- И последнее, что делает конструктор - возвращает `this`. Куда? В переменную `inputLogin`.

_Получается, что в переменной `inputLogin` хранится инстанс класса `Input`. А у этого инстанса есть только одно 
собственное поле - `domElement`, которое хранит в себе инстанс класса `HTMLElement`. А у этого инстанса мы поменяли его собственное поле `name` в значение 'login'._

- И потом мы делаем `appendChild` — внутрь `document.body` "зааппендим" фактически инстанс класса `HTMLElement`. 
Браузер знает про класс `HTMLElement` всё, и умеет его рендерить в `HTML`-тег.  

В результате внутри тега `body` возникает тег `<input name="login">`.

Зачем всё это надо?! Что-то наворотили-наворотили... На кой черт так сложно?!

Не спешите бросать этот учебник, вы всё поймёте, обещаю. Я даже смогу ответить на это недовольство, но немного позже.
 
Почему выше я говорил, что не существует _красивого_ способа описывать свои собственные классы в `Javascript`? 
Почему я так сказал? Вот смотрим мы с вами на функцию-конструктор и всё нам нравится - ладненькая такая функция, 
аккуратненькая, понятная. Что не так?

```javascript
function Input (params) {
    this.domElement = document.createElement('input');
    this.domElement.name = params.namуAttr;

    return this;
}

var inputLogin = new Input({namуAttr: 'login'});
```

Всё-таки читаем дальше и учимся, да? ;)

Отлично.

Не существует красивого _нативного_ способа описывать методы класса. До сих пор мы описывали свойства объектов, то есть поля. А как запрограммировать поведение - не обсуждали? Машина должна уметь двигаться и останавливаться. Инпут должен уметь реагировать на установку фокуса и нажатие двух клавиш на клавиатуре. Как реализовать это поведение внутри класса `Input`? И что очень важно отметить, как реализовать это внутри класса `Input` _нативным для `javascript`_ образом?

Ответ, который пугает каждого неопытного `js`-программиста, звучит сурово: "Через прототипы".

### Методы класса. Prototype

Это суровый ответ, потому что понять, что такое прототипы непросто. Это настолько чужеродное для человеческой культуры изобретение, что понять его смысл получается далеко не сразу. И далеко не у всех из нас. К примеру, я совсем недавно понял эти ужасные прототипы, когда моя коллега из Яндекс.Карт приготовила внутренний семинар на тему "Прототипы в Javascript". Она сделала это специально, чтобы рассказать о прототипах так просто, чтобы понял даже школьник. Школьников на её семинаре не было, а я был. И я понял. Спасибо тебе, Олеся!

И сейчас я вам расскажу очень понятно. Слушайте внимательно.

**Прототипы в Javascript - это... вообще не важно что**. Вообще! Вам не нужно задумываться, что это такое и как они устроены.

_Если очень-преочень интересно, Илья Кантор смог это объяснить [хорошо](https://learn.javascript.ru/prototype).  Но 
лучше не надо, поберегите себя. Хотя бы сейчас. Прочитайте через пару недель. Или через пару-тройку месяцев._

Чтобы пользоваться прототипами совершенно не нужно понимать, что это такое. Я, к примеру, не разбираюсь в устройстве своего автомобиля. Но езжу на нём каждый день. И с прототипами можно поступить так же.

Прототипы вы будете использовать для двух вещей:

1. Чтобы описывать методы ваших Классов.

2. Чтобы наследовать один ваш Класс от другого вашего Класса.

Всё! 

Как и почему это работает, — пожалуйста, – не задумывайтесь сейчас. Оно вам точно не надо. Пока не надо.

Созадим-ка лучше метод у класса `Input`:

```javascript
function Input (params) {
    this.domElement = document.createElement('input');
    this.domElement.name = params.namуAttr;

    return this;
}

Input.prototype.onFocused = function (e) {
    e.target.style.border = '1px solid yellow';
};
```

Чтобы в класс добавить метод, его нужно объявить не у самого класса, а у какого-то его служебного поля по имени 
`prototype`. Это самый правильный нативный способ добавлять методы в класс.

Почему это способ я называю некрасивым? Потому что хочется обходиться без всяких прототипов. Знаете, как хочется? К примеру очень хочется так:
```javascript
function Input (params) {
    this.domElement = document.createElement('input');
    this.domElement.name = params.namуAttr;

    this.onFocused = function (e) {
         e.target.style.border = '1px solid yellow';
    };

    return this;
}
```

И знаете, что? Так тоже можно. И это даже называют функциональным стилем программирования `javascript`-классов. Но я 
не рекомендую им пользоваться. Давным-давно, когда я только учился `ООП` на `Javascript`, я создавал классы таким 
образом и... мучался с ними. И вы намучаетесь, если будете описывать классы таким образом.

_Дело в том, что такой стиль рождает дополнительные трудности, которые приходится решать ещё более некрасивыми способами: всякими `call(this)` при каждом вызове методов класса или `bind(this)` для каждого описания метода класса . Об этом хорошо рассказал Илья в статье про [функциональное наследование](https://learn.javascript.ru/functional-inheritance), спасибо ему. Прочтите обязательно, только не сейчас. Потом можно ещё прочитать [сравнение функционального и прототипного способов](https://learn.javascript.ru/classes#сравнение), для полноты картины, так сказать._

Сейчас просто поверьте. Прототипный лучше :)

Итак, допилим наш класс, чтобы метод класса работал:
```javascript
function Input (params) {
    this.domElement = document.createElement('input');
    this.domElement.name = params.namуAttr;

    // Подписываемся на событие `focus` на инпуте
    // Когда на элементе сработает фокус, вызови наш собственный обработчик.
    this.domElement.addEventListener('focus', this.onFocused);

    return this;
}

Input.prototype.onFocused = function (e) {
    e.target.style.border = '1px solid yellow';
};

var inputLogin = new Input({namуAttr: 'login'});
document.body.appendChild(inputLogin.domElement);
```

Если этот код проверить в браузере, внутри тега `body` появится тег `input`. Мы его увидим в окне браузера. А если ткнём мышкой в этот инпут, то браузер создаст на инпуте событие `focus`. А так как мы в конструкторе класса подписались слушать событие `focus` на инпуте, то вызовется собственный метод `this.onFocused`, который мы описали через `Input.prototype.onFocused`.

Добавим ещё один обработчик - будем слушать кейап на инпуте. И можно добавить метод, с помощью которого инстанс класса будет сам себя рендерить внутри какого-то `html`-элемента, в нашем примере внутри `document.body`. И тогда нам не придётся каждый инстанс добавлять в дерево — он будет это делать сам из своего конструктора.
```javascript
function Input (params) {
    this.domElement = document.createElement('input');
    this.domElement.name = params.namуAttr;

    // Подписываемся на событие `focus` на инпуте
    // Когда на элементе сработает фокус, вызови наш собственный обработчик.
    this.domElement.addEventListener('focus', this.onFocused);

    // Подписываемся на событие `keyup` на инпуте
    // Когда пользователь нажмёт клавишу на клавиатуре, стоя курсором внутри инпута, вызови наш собственный обработчик.
    this.domElement.addEventListener('keyup', this.onKeyUpped);

    // Рендерим инпут на странице
    this.render();

    return this;
}

Input.prototype.onKeyUpped = function (e) {
    if (e.keyCode === 13) {
        // Нажали Enter
        console.log(e.target.value);
    } else if (e.keyCode === 27) {
        // Нажали ESC
        e.target.value = '';
    }
};

Input.prototype.onFocused = function (e) {
    e.target.style.border = '1px solid yellow';
};

Input.prototype.render = function () {
    document.body.appendChild(this.domElement);
};

var inputLogin = new Input({namуAttr: 'login'});
```

Всё. Теперь вы знаете всё, чтобы самому описывать собственные классы и создавать от них объекты. 

Посмотрим и сравним оба стиля программирования в одной таблице:

<table>   
<tr>
    <th>Процедурный стиль</th>
    <th>Объектно-ориентированный стиль</th>
</tr>
<tr>
   <td valign=top>
<pre>
var inputLogin = document.createElement('input');
inputLogin.type = 'text';
inputLogin.name = 'login';

var inputEmail = document.createElement('input');
inputEmail.type = 'text';
inputEmail.name = 'email';

var inputAge = document.createElement('input');
inputAge.type = 'text';
inputAge.name = 'age';

document.body.appendChild(inputLogin);
document.body.appendChild(inputEmail);
document.body.appendChild(inputAge);

inputLogin.addEventListener('focus', onInputKeyUpped);
inputEmail.addEventListener('focus', onInputKeyUpped);
inputAge.addEventListener('focus', onInputKeyUpped);

inputLogin.addEventListener('keyup', onInputKeyUpped);
inputEmail.addEventListener('keyup', onInputKeyUpped);
inputAge.addEventListener('keyup', onInputKeyUpped);

function onInputFocused (e) {
    e.target.style.border = '1px solid yellow';
}

function onInputKeyUpped (e) {
    if (e.keyCode === 13) {

        // Нажали Enter
        console.log(e.target.value);

    } else if (e.keyCode === 27) {

      // Нажали ESC
      e.target.value = '';

    }
}
</pre>
   </td>
   <td valign=top>
<pre>
function Input (params) {
    this.domElement = document.createElement('input');
    this.domElement.name = params.namуAttr;

    this.domElement.addEventListener('focus', this.onFocused);
    this.domElement.addEventListener('keyup', this.onKeyUpped);

    this.render();

    return this;
}

Input.prototype.onKeyUpped = function (e) {
    if (e.keyCode === 13) {
        console.log(e.target.value);
    } else if (e.keyCode === 27) {
        e.target.value = '';
    }
};

Input.prototype.onFocused = function (e) {
    e.target.style.border = '1px solid yellow';
};

Input.prototype.render = function () {
    document.body.appendChild(this.domElement);
};

var inputLogin = new Input({namуAttr: 'login'});
var inputEmail = new Input({namуAttr: 'email'});
var inputAge = new Input({namуAttr: 'age'});
</pre>
   </td>
</tr>   
</table>   

В чём главное преимущество ООП перед продурным стилем? В том, что все свойства и умения конкретного объекта мы 
описываем внутри самого объекта. В том, что каждый объект, инстанцированный от конкрентного класса гарантированно 
будет обладать всеми свойствами и умениями этого класса. В том, что код сайта больше не похож на спагетти из 
разношерстных функций, которые вызывают одна другую не-пойми-в-какой последовательности. Отныне ваш код — это 
объекты, наполненные смыслом и достоинством. А вы, программист такого сайта, — единовластный хозяин этих объектов, — 
только вы один решаете, какие объекты (и классы) создавать, и как они будут взаимодействовать в вашем скрипте. 

Эту идеальную картину омрачает единственный мазок — нативно `ООП` на `Javascript` реализуется с помощью 
малопонятного и, прямо скажем, нелицеприятного свойства `prototype`. Но знаете, что? Оказывается можно создавать 
объекты красиво, хоть и не нативно. Вам понравится, обещаю. Но об этом через 2 минуты, а пока подведем итоги тому, 
что мы узнали. 

### Что мы узнали?

`ООП` — это всего лишь ещё один способ организации своего кода.

`Класс` - это нечто вроде правил, по которым создаются объекты определенного типа. Можно думать, что `Класс` - это 
вспомогательные шаблоны, что ли. Сам по себе `Класс` не имеет смысла, он нужен для того, чтобы давать жизнь 
конкретным объектам.

`Объект класса`, он же объект какого-то типа (как мы его раньше называли) - это специальным образом сгруппированный 
код. Если раньше мы группировали свой код преимущественно в функции, то теперь мы предпочитаем организовывать код в 
некие объекты, которые обладают некими свойствами и умениями, называемыми соответственно полями и методами объекта. 
Такой объект, произведенный от конкретного класса принято называть `инстансом` этого класса, или `экземпляром`, кому как
 нравится.

В `Javascript`-е есть встроенные классы, и мы создавали от них инстансы, не подозревая, что мы это делаем. Когда мы 
создавали строковую переменную - мы как бы создавали инстанс класса `String`. Когда мы создавали массив — мы на самом 
деле создавали инстанс класса `Array`.

Но встроенных классов нам мало. Нам хочется уметь создавать свои собственные классы объектов, потому что мы 
порядком устали устали от процедурного стиля программирования и бесконечного списка своих функций, которые вызывают 
друга друга в запутанном порядке, от чего наш код довольно скоро становится плохо управляемым и нерасширяемым.

`ООП` - это способ разделения нашего кода на классы и порождённые ими объекты. Во всех больших языках, вроде `Java` 
или `C#` объектно-ориентированный подход программирования "встроен" по умолчанию. Мы хотим привнести его в 
`Javascript` и, к счастью, такая возможность есть.

Создать `экземпляр класса` очень просто. Это делает оператор `new`. Описать сам класс тоже просто, хоть и не очень 
красиво. Для этого используется, как ни странно, обычная функция, которая обязательно должна вернуть ключевое слово 
`this`.

Внутри этой функции (её ещё называют `конструктором класса`) мы можем объявить все свойства будущих объектов, 
которые мы будем создавать оператором `new` (их ещё называют `инстансами класса`). Свойства объявляются с помощью 
полей вида `this.something`.

А вот умения класса, а значит и умения каждого инстанцированного от этого класса объекта, мы описываем не в 
функции-конструкторе, а в отдельных методах, которые сохраняем в специальном и непонятном поле `prototype`. То есть,
 у каждого конструктора обязательно есть такое служебное поле по имени `prototype`. И именно в нём мы описываем 
 методы класса. Почему так придумано в `Javascript` - это отдельная тема, — нельзя сказать, что тема проста для 
 понимания. Но хорошо уже то, что её изучить можно сильно позже, или не изучать вовсе. 
 
Дальше мы будем говорить с вами о капсулирования информации в объектах, о наследовании, о способах общения объектов 
друг с другом. Но прежде всего мы поговорим о том, как же обойтись без уродующих наш код прототипов. Ну, ужас же! 
 
## Библиотека `inherit`

Всех `js`-программистов не устраивает ситуация с `prototype`. Конечно, возможно среди нас есть такие, кто любит каждое 
объявление метода присваивать классу через его прототип. Не знаю, может и есть. Но вообще-то ООП-программисты - народ, 
исповедующий красоту в коде. А в прототипах нет ни грамма красоты. Поэтому ООП-программисты придумали 
решение, которое в общем виде выглядит, как функция, которая работает с прототипами сама. А мы лишь описываем 
классы так красиво, как нам хочется. 

Помните, как нам хотелось бы это делать? Я показывал выше код и говорил, что _так_ красиво, только рождает 
проблемы:
```javascript
function Input (params) {
    this.myProperty = params.value;

    this.myMethod = function () {
        console.log(this.myProperty);
    };

    return this;
}
```

То есть, хочется, чтобы класс описывался в одном цельном фрагменте кода, без распыления на объявления методов через 
прототипы.

А вот как выглядит ровно этот же код с помощью специализированной функции `inherit`:
```javascript
var Input = inherit({
    __constructor: function (params) {
        this.myProperty = params.value;
    },

    myMethod: function () {
        console.log(this.myProperty);
    },
});
```

Инстанцироваться от него точно так же, как и раньше: `var inputLogin = new Input();`. 

И вот каким красивым и понятным становится наш пример уже с использованием функции `inherit`:
```javascript
var Input = inherit({
    __constructor: function (params) {
        this.domElement = document.createElement('input');
        this.domElement.name = params.namуAttr;
    
        this.domElement.addEventListener('focus', this.onFocused);
        this.domElement.addEventListener('keyup', this.onKeyUpped);
    
        this.render();
    },

    onKeyUpped: function (e) {
        if (e.keyCode === 13) {
            console.log(e.target.value);
        } else if (e.keyCode === 27) {
            e.target.value = '';
        }
    },
    
    onFocused: function (e) {
        e.target.style.border = '1px solid yellow';
    },
    
    render: function () {
        document.body.appendChild(this.domElement);
    }
});

var inputLogin = new Input({namуAttr: 'login'});
var inputEmail = new Input({namуAttr: 'email'});
var inputAge = new Input({namуAttr: 'age'});
```

Никаких тебе прототипов, весь класс `Input` описывается одним логически понятном фрагментом кода. Красота.

Эту функцию придумал и создал наш коллега из Яндекса, — Дмитрий Филатов, — вот 
[репозиторий этого проекта](https://github.com/dfilatov/inherit). Почему функция называется именно `inherit` и 
что она умеет делать ещё, мы поговорим ниже. А сейчас минутка признательности. 

_Дима, спасибо тебе большое!_
_Именно благодаря твоему решению я полюбил программирование в объектно-ориентированом стиле на `Javascript`._

В недалёком будущем в `Javascript` можно будет создавать классы нативно и красиво одновременно. Заглянем в будущее на 
мгновение и увидим, как мы перепишем наш класс, когда все браузеры поддержат новый стандарт `Javascript` — 
`ECMAScript 2015 (ES6)`:

<table>
<tr>
    <th>Настоящее: с помощью `inherit`</th>
    <th>Будущее: `ECMAScript 2015 (ES6)`</th>
</tr>
<tr>
   <td valign=top>
<pre>
var Input = inherit({
    __constructor: function (params) {
        this.domElement = document.createElement('input');
        this.domElement.name = params.namуAttr;
    
        this.domElement.addEventListener('focus', this.onFocused);
        this.domElement.addEventListener('keyup', this.onKeyUpped);
    
        this.render();
    },

    onKeyUpped: function (e) {
        if (e.keyCode === 13) {
            console.log(e.target.value);
        } else if (e.keyCode === 27) {
            e.target.value = '';
        }
    },
    
    onFocused: function (e) {
        e.target.style.border = '1px solid yellow';
    },
    
    render: function () {
        document.body.appendChild(this.domElement);
    }
});
</pre>
    </td>
   <td valign=top>
<pre>
class Input {
    constructor: function (params) {
        this.domElement = document.createElement('input');
        this.domElement.name = params.namуAttr;
    
        this.domElement.addEventListener('focus', this.onFocused);
        this.domElement.addEventListener('keyup', this.onKeyUpped);
    
        this.render();
    },

    onKeyUpped: function (e) {
        if (e.keyCode === 13) {
            console.log(e.target.value);
        } else if (e.keyCode === 27) {
            e.target.value = '';
        }
    },
    
    onFocused: function (e) {
        e.target.style.border = '1px solid yellow';
    },
    
    render: function () {
        document.body.appendChild(this.domElement);
    }
}
</pre>
    </td>
</tr>
</table>

В будущем нам придётся совсем немного переписать наш код, чтобы он работал с нативными классами. А пока будущее не 
наступило, мы будем пользовать функцией-хелпером `inherit`. Дима, спасибо тебе большое.

Использовать эту функцию очень просто. Подключите её на страницу любым удобным вам способом — либо в теге `<script>`,
 либо настройте свою `Grunt/Gulp/Webpack/WhatElse?`-сборку, чтобы содержимое файла 
 [inherit.js](https://github.com/dfilatov/inherit/blob/master/lib/inherit.js) попало в собранный вами `page.js` и 
 пользуйтесь.
 
Эта функция настолько прекрасна, что в Яндексе не представляют жизни без неё. С её помощью можно не только описывать
 классы. Можно наследовать классы, доопределять и переопределять поля и методы базового класса, вызывать методы 
 базового класса из производного. Обо всём этом мы поговорим.
 
Но прежде - про публичный и приватный интерфейсы объекта.

### Публичный и приватный интерфейсы

Можно считать эту тему краеугольной в `ООП`. Поймём её один раз и будем использовать классы с объектами максимально 
эффективно. Поэтому... садимся в машину.
 
Я уже говорил, я ежедневно езжу на автомобиле, совершенно не разбираясь в его устройстве. Вы точно так же в 
жизни пользуетесь множеством предметов, не представляя, насколько сложно они устроены внутри. Да что там далеко 
ходить за примером, моей дочери 10 лет и она вообще ничего не знает про устройство её ноутбука. Но видели бы вы, как 
 вирутозно она им пользуется. 

Вообще-то это правильно — прятать сложное устройство предмета под капот, под крышку, под днище... То есть туда, куда 
пользователь устройства не сможет залезть случайно. Пользователю нужно оставлять только минимальный, 
но достаточный, набор органов управления. В машине это руль, педали, ручки, кнопки, двери. В компьютере это 
клавиатура, дисковод, разъемы для внешних носителей. Самый минимум, но достаточный для эффективного использования 
предмета.
  
Ровно этот же принцип программисты перенесли из жизни в программы.

