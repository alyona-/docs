# Объектно-ориентированное программирование

В классических учебниках эту тему объясняют на примере машины.

Мол, автомобиль - это класс объектов. Если выражаться привычными нам словами, это категория объектов. Эта категория (класс) имеет характерные признаки - 4 колеса, двигатель, салон для пассажиров. Автомобили умеют двигаться в пространстве и перевозить людей. И там, в учебниках, утверждается, мол, **все** автомобили имеют **все эти** характерные признаки, а например, лифты не имеют **всех этих** признаков, а имеют какие-то свои признаки, значит они принадлежат к другому классу объектов.

А объект — это, мол, конкретная машина, созданная на конкретном автомобильном заводе. Она имеет все характерные признаки класса автомобиль (4 колеса, двигатель, салон...), но это уже не абстрактный класс (не абстрактная категория автомобилей), а вполне себе реальная штуковина, которую можно пощупать, в неё можно сесть, завести и поехать на море.

То есть класс, объясняли в учебнике, - это сущность абстрактная, шаблонная, она лишь описывает признаки (или правила), по которым нужно создавать конкретный экземпляр. Экземпляр класса. Или другими словами, объект класса. А вот объект - это уже  конкретная реализация этого класса.

Я когда читал эти объяснения в учебнике, я всё понимал. Про автомобили - всё понимал. Про ООП в `Javascript` - ничего. Как эти знания про автомобили применить к к моим программам? Непонятно.

Попыток объяснить эту тему существует множество. Можно прочитать [здесь](), и [здесь](), и [ещё здесь]().

Но я всё же собираюсь предпринять свою собственную попытку. Потому что меня не устраивают объяснения всех этих бесспорно уважаемых людей.
Я попытаюсь вам объяснить эту тему так, как собираюсь объяснять её  своей дочери годика эдак через четыре. То есть, понятно. И не про автомобили и лифты, а именно про `Javascript`.

## Что нужно знать?

К тому моменту, когда дочь будет готова воспринимать эту тему, она должна будет понимать, что такое переменные, какие типы переменных существуют в `javascript`, какие методы существуют у встроенных типов (например, у строк, у чисел, у массивов). Дочь должна уметь создавать функции, уметь их вызывать и принимать от них результаты.

Если всей этой базы не понимать, задаваться вопросом, что такое объектно-ориентированное программирование, совершенно незачем. ООП - это абстракция над базовыми возможностями `javascript`. Если не знать базовых возможностей, глупо лезть в дебри.

Я предполагаю, что вы прекрасно разбираетесь в основах. Поэтому вперёд.

ООП - это такой способ написания кода, когда мы пишем свой код в терминах так называемых `Классов` и `Объектов`. Не в виде набора функций, а в виде...

## Вообще-то вы уже знаете, что такое ООП!

Конечно же! Не ослышались. И хотя даже школьник  знает, что `Javascript` вообще ни разу не объектно-ориентированный язык, вы должны знать, что когда вы пишете `javascript`-программу, вы чуть ли не в каждой строчке своего кода создаёте `Объекты` из `Классов` и оперируете им мастерски. Только этого ещё не понимаете. Каждый из нас _уже умеет_ писать объектно-ориентированные программы.

```javascript
var name = 'Bevis';
```
Что в этом коде происходит? Ничего  магического. Создаём переменную `name` строкового типа и присваиваем ей значение 'Bevis'. Вам этот оператор  совершенно понятен. Ну, переменная. Ну, строкового типа. Ну и?

На самом деле, этот же оператор должен быть записан иначе. Вы это наверняка знаете. Или знали раньше, но забыли:
```javascript
var name = new String('Bevis');
```
Этот код совершенно идентичен предыдущему. Но я попробую предположить, что разработчики `Javascript` пожалели нас, бедных, и дали нам возможность писать это же короче - без вызова оператора `new` и без указания типа `String`. Спасибо им. Но что такое `new String()`? Сравним описания:

Создаём **переменную** `name` строкового **типа** и присваиваем *переменной* значение 'Bevis':
```javascript
var name = 'Bevis';
```

Создаём **объект** `name` строкового **класса** (то есть, класса `String`) и присваиваем *объекту* значение 'Bevis':
```javascript
var name = new String("Bevis");
```

То есть вместо слова `Тип` можно смело говорить слово `Класс`. Считайте, это одно и то же. А вместо слова ``Переменная`` можно смело говорить слово ``Объект``.

Вы так не говорили никогда. Я тоже так не говорил. Нас не учили так говорить ни в одном учебнике. Но если мы хотим научиться писать объектно-ориентированные программы, нужно взглянуть на свои программы под новым углом. Мне кажется, если вы поймёте, что любая переменная, которую вы создавали в своей жизни, на самом деле никакая не переменная, а Объект какого-то Класса, понять всё остальное в ООП будет легко. Попробуйте вместе со мной относиться к переменным именно так. Договорились, пробуем?

Итак, когда вы создаёте строковую переменную, на самом деле вы создаёте объект строкового класса. Или "экземпляр класса String". Замысловато звучит, чужеродно даже. Но так принято, все ООП-адепты выражаются именно такими словами и другу друга понимают. И мы привыкнем, и мы научимся.

Итак, когда мы пишем `var name = 'Bevis'`, на самом деле мы создаём не строковую переменную, а экземпляр класса "Строка". Или, другими словами, объект класса "Строка".

В учебниках про `javascript` вы на первых же страницах читали про встроенные типы данных. Вы, конечно, их знаете:
- String
- Number
- Boolean
- ...

Давайте перестанем думать о них, как о **типах** данных, а будем относиться к ним, как к **классам** данных.

_Правильно это с академической точки зрения или нет, я уверен, вообще не важно. Я хочу, чтобы вы осознали прямо сейчас — вы каждый день пишете программы с использованием классов и объектов, только не называете их этими словами. Как только вы это осознаете, вы легко поймёте, как создавать и как пользоваться своими собственные классами и объектами. Но про свои классы и объекты чуть позже. А пока начнём привыкать к новым словам._

Как любая реальная машина имеет 4 колеса, двигатель и салон, так и любой объект, созданный из класса `String` имеет имеет свой характерный набор признаков. Это же понятно, да?

```javascript
var name = new String("Bevis");
console.log(name.length); // 5
```

Мы только что создали объект `name`, и у него вдруг появляется свойство `length`, хотя мы такое свойство не определяли. Оно появилось само собой. Откуда? Вы прекрасно знаете, что любая строковая переменная обладает таким свойством, эка невидаль. Но давайте подумаем об этом по-новому. Покатайте в уме такое объяснение: любой экземпляр класса `String` обладает свойством `length`. Как только мы создали новый экземпляр класса с помощью оператора `var name = new String('Bevis')` (или с помощью шотката `var name = 'Bevis'`, что одно и то же ) и сохранили его в объекте `name`, созданный объект приобрел сразу все характерные признаки класса `String`.

 У любой строки есть такая вещь, как длина строки. Это признак строки? Признак, конечно. А есть ли такой признак у числа? Правильнее было бы задать этот вопрос другими слоами: "А есть ли точно такой же признак у объекта, созданного от класса `Number`"? Нет.

 Доказываю. Создаём объект класса `Number` и спрашиваем у него длину:
```javascript
var age = new Number(36);
console.log(age.length); // undefined
```
Нет такого свойства у экземпляра класса `Number`. Да вы и сами это знаете, только никогда не рассуждали об этом словами `Класс` и `Объект`.

На заводе конкретную машину делают по правилам класса "Автомобиль". А в программах на `js` мы создаём строковые, числовые и булевские переменные с помощью встроенных в `Javascript` классов `String`, `Number`, `Boolean`.

Не только примитивные объекты мы создаём.

Вы писали такое множество раз:
```javascript
var data = [];
```

Это тоже шоткат. На самом деле это тоже создаётся экземпляр класса `Array`:
```javascript
var data = new Array();
```

Вы поняли, что в `javasсript` вы всё время создавали объекты из классов? Вы этим занимались всю свою жизнь, только не думали об этом в таком ключе.

Чтобы окончательно убедить вас в этом, последний довод.

Вы когда-нибудь генерили картинки налету и вставляли в DOM? Конечно. Не таким ли образом вы это делали?
```javascript
var logo = new Image();
logo.src = "picture-of-your-company.jpg";
logo.alt = "Company's Logotype";
logo.title = "Изготовление сайтов под ключ";
document.body.appendChild(logo);
```

Этих 4-х строк достаточно, чтобы в теге `body` появился новый тег
```html
<img src="picture-of-your-company.jpg" alt="Company's Logotype" title="Изготовление сайтов под ключ">
```

В результате
- мы увидим на странице изображение, реализованное тегом `img`.
- браузер навесит на изображение какие-то дефолтные `CSS`-стили.
- снабдит изображение своим собственным особенным поведением:
  - если вдруг картинка по `HTTP` не подгрузится, на её месте браузер покажет текст "Company's Logotype"
  - а если пользователь подведет курсор мыши к картинке, браузер покажет всплывающий тултип с текстом "Изготовление сайтов под ключ"".

Для вас это вообще не новость. Но задумайтесь — мы написали один простой оператор `new Image()` и получили объект, который обладает сразу и  `HTML`-разметкой, и `CSS`-стилями и интерактивным поведением. Получается, что в браузер встроен класс объектов `Image`. Когда мы написали оператор `new Image()`, мы создали экземпляр класса `Image`.

_Кстати, экземпляр класса ещё называют инстансом класса от англ. ["instance"](https://translate.yandex.ru/?text=%D1%8D%D0%BA%D0%B7%D0%B5%D0%BC%D0%BF%D0%BB%D1%8F%D1%80&lang=ru-en)._

Это и называется `Объектно-Ориентированное Программирование`.

Ах, как жаль, что таких встроенных в браузер классов очень мало. Почему нет класса `Input`, `Button`, `Form`? Как было бы легко программировать веб-сайты, если бы таких классов было много и сразу. Но их нет. Это минус. Зато их можно создавать самим, и это плюс. Цель этого туториала — показать вам, что создавать свои собственные классы - это очень просто. Программировать в ООП-стиле на `Javascript` - это просто и удобно.

Попробовав это один раз, вы влюбитесь в ООП-стиль и будете удивляться, как же вы программировали раньше без ООП?

Подводём быстрые итоги.

В `Javascript` мы всё время оперируем не просто переменными (как мы всегда думали), а исключительно конкретными инстансами классов. Создаём ли мы строковую переменную или чисельную, или логическую, или массив, или функцию(!), или картинку — на самом деле мы создаём экземпляры соответствующих классов `String`, `Number`, `Boolean`, `Array`, `Function` или `Image`. Вы делали это в каждой программе. Вы умеете это делать в совершенстве.

Только вы использовали _уже существующие_ в `Javascript` классы. А теперь нам хочется у меть создавать свои собственные классы, чтобы сделать код ещё более удобным.

## Как мы программируем по-старинке.

Начинающие веб-программисты думают про `web`-страницы, как про набор `html`-тегов. Например, элементы формы "текстовое поле" - это тег `<input type="text">`. Как на странице может появиться такой тег?

1. Сервер может построить `html` страницы и отдать в браузер. И в этом `html` где-то внутри `body` уже будет такой тег.
2. Мы можем на стороне браузера сгенерить такой тег в клиенстком `js`.

Серверную генерацию рассматривать не будем, это скучно. Хочется веселья. Как мы можем сгенерить инпут налету?
```javascript
var myInput = document.createElement('input');
myInput.type = 'text';
document.body.appendChild(myInput);
```

Или можно с помощью jQuery:
```javascript
var myInput = $('<input type="text">').appendTo('body');
```

В обоих случаях внутри тега `body` появится новый тег `input`.

Нам хочется, чтобы этот инпут взаимодействовал с пользователем.  Например:
1. Если пользователь поставил курсор в поле, обвести поле фокусной рамкой нужного цвета.
2. Если поле находится в фокусе, и пользователь ввел какой-то текст в поле, а затем нажал кнопку `ESC`, очистить поле от введенного значения.
3. Если поле находится в фокусе, и пользователь нажал кнопку `Enter`, вывести введенное значение в консоль браузера.

Такого поведения браузер не обеспечил для вновь созданного инпута. Значит это должны сделать мы. Предположим, что вы пишете с использованием jQuery, тогда ваш код будет выглядеть приблизительно так:

```javascript
// Создаём инпут
var myInput = $('<input type="text">').appendTo('body');

// Добавляем в DOM
document.body.appendChild(myInput);

// Слушаем событие focus
myInput.focus(onInputFocused);

// Слушаем нажатие на клавиши клавиатуры
myInput.keyup(onInputKeyUpped);

// Описываем обработчик фокуса
function onInputFocused (e) {
    e.target.css('border', '1px solid yellow');
}

// Описываем обработчик нажатия на клавиши клавиатуры
function onInputKeyUpped (e) {
    if (e.keyCode === 13) {

        // Нажали Enter
        console.log(e.target.value);

    } else if (e.keyCode === 27) {

      // Нажали ESC
      e.target.value = '';

    }
}
```

Возможно, я допустил ошибки. Скорее всего, этот код можно оптимизировать. Не сомневаюсь, вы напишете его лучше.

Но я не об этом. Давайте подумаем, где этот код мы пишем? Я предполагаю, что у вас есть какой-то `page.js` файл, в котором вы пишете всю программу. Этот `page.js` подключается на веб-страницу с помощью тега `<script src='page.js'></script>`. И вы представляете себе очень хорошо, что когда этот файл загрузится в память браузера, запустится интерпретатор языка `Javascript`, который будет читать каждую строку в вашем файле `page.js` сверху вниз и выполнять одну за другой. По-строчно, одну за одной.  В какой-то момент интерпретатор дойдёт до строк, где мы создаём инпут и навешиваем на него обработчики событий. Выполнит операторы в этих строках и пойдёт дальше. С этим проблем нет. Это вы понимаете. А что тут не понять, спросите вы?

У меня один вопрос. А если мы создаём не один инпут? Если мы должны создать два, три, четыре инпута. На что это станет похоже. Я вам покажу:

```javascript
//  Создаём три инпута
var inputLogin = $('<input type="text" name="login">').appendTo('body');
var inputEmail = $('<input type="text" name="email">').appendTo('body');
var inputAge = $('<input type="text" name="age">').appendTo('body');

// Добавляем в DOM
document.body.appendChild(inputLogin);
document.body.appendChild(inputEmail);
document.body.appendChild(inputAge);

// Слушаем событие focus на каждом инпуте
inputLogin.focus(onInputFocused);
inputEmail.focus(onInputFocused);
inputAge.focus(onInputFocused);

// Слушаем нажатие на клавиши клавиатуры на каждом инпуте
inputLogin.keyup(onInputKeyUpped);
inputEmail.keyup(onInputKeyUpped);
inputAge.keyup(onInputKeyUpped);

// Описываем обработчик фокуса
function onInputFocused (e) {
    e.target.css('border', '1px solid yellow');
}

// Описываем обработчик нажатия на клавиши клавиатуры
function onInputKeyUpped (e) {
    if (e.keyCode === 13) {

        // Нажали Enter
        console.log(e.target.value);

    } else if (e.keyCode === 27) {

      // Нажали ESC
      e.target.value = '';

    }
}
```

Уже некрасиво. А если нам не только  инпуты создать надо, а ещё форму. А ещё шапку сайта. Или подвал. Или вообще все-все элементы на странице нам надо создавать налету? Создавая код по старинке, мы получим огромную простыню операторов. Интерпретатор `Javascript` жаловаться не будет, ему всё равно - он все прочитает и выполнит. Но ведь нам, людям, такой код читать и поддерживать трудно. Больно.

_Конечно, можно этот код разносить по нескольким файлам, а потом склеивать их в один `page.js` с помощью какого-то сборщика вроде `Grunt`, `Gulp` и т.п. Я вам так скажу - не только можно, а нужно. Необходимо! Этим вы хотя бы немного облегчите себе работу с этим кодом._

Но просто разносить такой код по отдельным файлам мало помогает.

Вот, если бы (давайте помечтаем вслух) в браузере уже существовал специальный класс `Input`? А в нём были бы описаны все нужные обработчики событий? Как бы мы тогда создали три инпута?

Наверное так:
```javascript
//  Создаём три инпута
var inputLogin = new Input({name: 'login'});
var inputEmail = new Input({name: 'email'});
var inputAge = new Input({name: 'age'});

// Добавляем в DOM
document.body.appendChild(inputLogin);
document.body.appendChild(inputEmail);
document.body.appendChild(inputAge);
```

Вставка в DOM никуда бы не делась. А вот описывать обработчики для каждого инпута нам  уже не нужно. _Было бы_ не нужно. Красота.

К счастью, мы можем такую красоту сделать сами.

## Создаём объекты из классов — оператор `new`

Об операторе `new` можно почитать в учебнике Ильи Кантора: [https://learn.javascript.ru/constructor-new](https://learn.javascript.ru/constructor-new). Прочитайте обязательно.

Но даже если не прочитали, вы уже поняли, что оператор `new` нужен для того, чтобы создать инстанс какого-то класса, экземпляр этого класса, конкретный объект класса. Что происходит под капотом этого оператора, прямо сейчас совершенно не важно знать. Важно понять одно - для создания инстансов класса в языке `Javascript` всё есть.

Чего в нём нет, так это _красивого_ способа описывать свои собственные Классы. Слово "красивого" я выделил курсивом не случайно. Нет именно красивого способа. А вообще-то такой способ есть. Он странный и чужеродный для понимания человеком, но он есть. И мы сейчас его изучим.

Раз уж браузер не обеспечил нас, разработчиков, классом `Input`, напишем его сами.

Напомню, создавать инстанс этого класса мы хотим так:
```javascript
var inputLogin = new Input({name: 'login'});
```

## Описываем свой класс с помощью `Function`

Вы прекрасно знаете, что такое функции. Вы создавали их так так:
```javascript
function getValue () {
    // ...  
}
```

Или так:
```javascript
var getValue = function () {
    // ...  
}
```

А знаете, как описать класс `Input`? Вот так:
```javascript
function Input () {
    // ...  
}
```

Забавно, да? Любая функция может стать классом, если выполнить два условия — одно критичное, второе некритичное.
1. Имя функции начинается с заголавной буквы. Это некритичное требование, ему можно не следовать. Но лучше его выполнять, чтобы вы сами могли отличить по именам, где простая функция, а где целый класс.
2. Внутри функции появляется ключевое слово `this`.

В примере выше я выполнил только первое требование. Вот как я выполню второе требование и сразу создам инстанс класса `Input`:
```javascript
function Input (params) {
    this.name = params.name;
}

var inputLogin = new Input({name: 'login'});
console.log(inputLogin.name); // --> login
```

Что произошло?

Я создал объект класса `Input`. Создал инстанс (ещё говорят, инстанцию) класса. То есть я создал конкретный инпут. Да, этот инпут пока ничего не умеет - ни html для себя создавать, ни реагировать на действия пользователя — ничего. Всё, что он умеет - хранить в себе поле `name` и заполнять его данными, которые передали при инстанцировании класса `Input`.

Мудрено? :)

И тут мы вернемся с вами к классическому примеру с машинами. Самое время :)

Есть набор правил, по которым создают автомобили. Эти правила гласят, что у любого автомобиля есть набор неких свойств и неких умений.

Например, любой автомобиль должен иметь 4 колеса (обычно, у машин всё таки 4 колеса, хотя были попытки сделать и трёхколесные). У автомобиля должен быть двигатель. Руль. Двери. Салон для пассажиров. С точки зрения ООП эти свойства называются `полями` автомобиля.

Ещё автомобиль должен уметь двигаться. Должен уметь останавливаться. Двери должны уметь открываться и закрываться, чтобы в салон могли сесть пассажиры. С точки зрения ООП эти все умения называются `методами` автомобиля.

_То есть свойства объекта мы в ООП называем "полями", а умения объекта называем "методами". Это понять можно, а пока предлагаю просто запомнить. Когда мы будем говорить слово "поле объекта" или "поле класса", вспоминайте свойства автомобиля. А когда будем говорить "метод объекта" или "метод класса", вспоминайте умения автомобиля._






----

_Итого, в ООП используется всего две сущности: `Класс` и `Объект класса` (он же `экземпляр` класса, он же `инстанс` класса)._
