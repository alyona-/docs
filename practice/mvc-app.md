# Используем `MVC`-концепцию в `BEViS`-проекте

Мы любим `MVC` за то, что эта концепция наводит порядок в проекте, сортирует компоненты кода по трём признакам — 
Модель, Представление и Контроллер. Отличную статью можно прочитать на 
[Вики](https://ru.wikipedia.org/wiki/Model-View-Controller).

Важно понимать, что в этом документе мы будем говорить о внедрении MVC в _клиентские модули_. Не в `bt`-шаблоны и не 
в серверный `js` из папки `server`. Мы внедрим `MVC` в код, который работает в браузере.

Когда мы говорим "внедрим `MVC`", это не означает, что мы станем внедрять какие-то одни фрагменты кода внутрь 
каких-то других фрагментов кода. Нет, конечно. `MVC` - лишь способ абстрактного отношения к своему коду и 
способ разделить ответственность, распределить роли между фрагментами кода ради того, чтобы уменьшить связность 
компонентов кода друг с другом, то есть чтобы изменение одного компонента не приводило к необходимости вносить 
изменения в работу другого. Для этого все компоненты кода разделяются на три условные группы, на три роли — модель, 
представление и контроллер. Модель отвечает за данные. Представление отвечает за отображение данных.  А контроллер — 
это мозговой центр программы, связывает модели и представления в единую систему.

_Строго говоря, согласиться с предыдущими словами можно только при условии, что мы описываем так называемую пассивную
 версию `MVC`, потому что в активной `MVC` мозговым центром программы является именно модель. Но, как интересно 
 подметили в статье на Вики, веб-разработчики пользуются пассивной MVC, потому что опыт программирования скриптов на PHP 
  испортил нас._

Мы будем строить приложение на основе пассивной `MVC`. И если вынырнуть из мира программирования и оглядеться вокруг,
  такое распределение ролей можно увидеть во многих аспектах обычной жизни. 

Возьмём большой магазин, например, с бытовой техникой. 

Где-то на хозяйственном дворе за магазином есть складские помещения, и там работает складской рабочий. Его задача - 
получить новый товар от поставщиков. Те на фурах привозят товар, кладовщик его принимает и раскладывает на полках 
склада. Это одна его функция. Вторая функция кладовщика - отдать товар в магазин, когда из магазина придёт заявка с 
текстом: "Выдать столько-то микроволновок LG и столько-то телевизиров SONY Bravia." 

Кладовщик находит на полках склада нужные микроволновки и телевизиры и передаёт в магазин. Он не знает, кому он 
отдаёт товар — ему это знать не нужно. Не его это забота.
  
В то же время в самом магазине работает консультант. Его задача — принять откуда-то взявшиеся микроволновки и 
телевизоры и выставить их на полки магазина. Выставить аккуратно, развесить ценники, наклеить рекламки про скидки 
(консультант всё это знает, у него такая ответственность). Это одна из его функций. Вторая функция консультанта — 
общаться с покупателями. Слушать и отвечать на вопросы, взаимодействовать любыми способами, лишь бы товар купили.
 
Важно, что кладовщик не расставляет товар на полках магазина и не общается с покупателями. А консультант магазина не 
принимает товар от поставщиков на складе. Это в маленьком магазине работает один человек - он продавец, он же и 
кладовщик. А в больших магазинах приходится делить обязанности, чтобы не тормозить процесс. Было бы очень 
неэффективно и медленно, если бы один человек делал всё — принимал товар от поставщиков, потом оформлял бы его, потом 
расставлял по складу, потом нёс бы его в салон магазина, там расставлял и, уже порядком вспотевший и чертовски 
уставший, через силу улыбался бы покупателям и пытался бы отвечать на вопросы.
 
Кладовщик ведает только задачами склада. Консультант занимается только представлением товара на витринах и 
общением с покупателями. Эти два специалиста вообще не пересекаются друг с другом и друг от друга не зависят. Так 
эффективнее.

И тут возникает ещё один сотрудник магазина, который должен организовать работу кладовщика и консультанта. Назовём 
его менеджером. Именно он опрашивает консультантов: "Сколько каких товаров нужно выставить на витрины", и пишет 
 заявку кладовщику: "Выдать столько-то микроволновок LG и столько-то телевизиров SONY Bravia." Именно он 
 переправляет этот товар со склада в помещение магазина (не сам, конечно, но процесс организовывает именно он).
 
Менеджер — мозговой центр, который организует потоки товара и связывает все другие роли в магазине в единое целое.

_Понятно, что в торговле есть ещё много других ролей и на тех же складах и в салоне магазина. Понятно, что и  
менеджеры делятся на какие-то категории, но это не меняет сути — в сложном процессе участвуют 
специализированные сотрудники, среди которых можно выделить три — получение + хранение товара, представление товара + 
общение с покупателями, управление потоками товара._

Аналогично магазину, в программирование привнесли те же три роли.

*Кладовщик - это Модель (`Model`)*
  
  * Кладовщик получает данные от поставщиков, а Модель получает данные из бекенда — из базы данных или из других 
  сервисов, обращаясь к ним по `HTTP`.
  
  * Кладовщик расставляет товар по полкам склада, а Модель сохраняет данные в каких-то внутренних объектах или массивах.
  
  * Кладовщик по заявке отпускает товар, а Модель отдаёт данные из своего хранилища. Как кладовщику, так и модели без 
  разницы, кто запросил данные — отдал и всё.

*Консультант - это Представление (`View`)*
  
  * Консультант расставляет товар в витринах, чтобы товар было хорошо видно. Представление отображает данные на 
веб-странице, навешивает стили, анимирует — отображает данные привлекательно. Представление не должно знать, откуда  
пришли данные. Ему это знать не за чем. 
 
  * Консультант слоняется между витринами в магазине и ждёт, пока потенциальный покупатель задаст ему вопрос о 
  микроволновке. Тогда Консультант покажет микроволновку со всех сторон, расскажет о ней. Представление точно так же 
  слушает пользовательские события на веб-странице (клики там, или чейнджи в инпутах) и как-то реагирует на эти 
  события. Например, по клику в инпут в обработчике клика `View` инпута сделает вокруг текстового поля жёлтую фокусную 
  рамку — поменяет своё же представление.
 
  * Когда Консультанта просят продать эту микроволновку с витрины, он относит её на кассу (менеджеру) и сообщает там,
   что товар хотят купить. Когда пользователь ввёл логин и пароль в форму авторизации и нажал Enter, Представление 
   формы читает тексты из полей логина и пароля и передаёт их Контроллеру. И больше вью формы ничего не делает — 
   только собирает данные от пользователя и отдаёт контроллеру.

*Менеджер - это Контроллер (`Controller`)*
  
  * Как Менеджер организует работу в магазине, так Контроллер организует работу `web`-приложения. Именно в файле 
  Контроллера начинается работа приложения. Имено здесь мы управляем, из каких Моделей нужно запросить данные. 
  Именно здесь мы полученные данные перенаправляем в Представления. Именно здесь мы получаем сообщения от View, что 
  пользователь ввёл "такой-то текст" в "таком-то" View и нажал сабмит. И делаем то, что нужно — отправляем этот текст
   в модель, чтобы передать данные в бекенд или ещё что-то, не знаю что.
    
Так устроено `javascript`-приложение на `MVC`. Всё три роли общаются друг с другом с помощью кастомных событий, мы о 
них немного уже говорили в [yblock.md](yblock.md).

Ещё мы с вами создавали три компонента — `Input`, `SuperInput` и `Form`. Если посмотреть на них через призму `MVC`, 
окажется, что они и есть Представления. То есть, до сих пор в практикуме мы создавали только модули-представления и 
как-то их друг с другом связывали. Всё это было вью. Конечно, мы сейчас создадим и контроллеры и модели, но сначала 
нужно подготовить файловую систему — чтобы модели, контроллеры и вью жили каждый в своем доме. Кладовщик на склад, а 
консультант в салон магазина. Поехали.
  
## Файловая организация для `MVC` 
 
До сих пор мы разрабатывали проект, файловая структура которого выглядела так:
````
/blocks
/configs
/core
/pages
/server
````

_Я опустил служебные папки, оставил только те, которые нужны для объяснения._

Это странная файловая структура — на одном уровне мы сложили совершенно разноуровневные директории. Например, 
`server` и `blocks` — почему они рядом? Первая содержит код для создания `Node.js`-приложения, а вторая содержит наши
 формочки и инпуты. Совершенно разный масштаб, разная важность, разная предметная область. Непонятно. Неправильно 
 как-то. Будем исправлять :)
  
`MVC` - это же `javascript`-приложение? Оно имеет и серверный код и клиентский код? Кажется логичным в корне проекта 
сделать две схожие по назначению директории: `server` и `client`. В первой будет всё, что относится к `Node.js` (к 
серверной части приложения), во второй - к клиентской. Например, `blocks`, `core`, `pages` — это же всё имеет 
отношение к фронтенду — блоки, страницы. Пусть живут в `client`:
````
/client
    /blocks
    /core
    /pages
/configs
/server
````

Вы можете переделывать файловую структуру со мной вместе. А можете посмотреть как это реализовано в 
[отдельной ветке](https://github.com/bevis-ui/bevis-stub/tree/mvc-application), где я переформатировал `bevis-stub` 
под `MVC`. *ВЕТКА ЕЩЁ НЕ ГОТОВА ДЛЯ ДЕМОНСТРАЦИИ*
 
### Пути к директориям с исходниками
Так как мы перенесли директорию `pages` в другое место, сборщику проекта нужно об этом сообщить. Он-то поди ещё не 
знает, чтобы папка уехала и будет пытаться найти её по прежнему адресу. Настройка сборки проекта находится в файле 
`.enb/make.js`

```javascript
var fs = require('fs');
var path = require('path');

module.exports = function (config) {

    config.setLanguages(['ru', 'en']);

    config.includeConfig('enb-bevis-helper');

    var bevisHelper = config.module('enb-bevis-helper')
        .browserSupport([
            'IE >= 9',
            'Safari >= 5',
            'Chrome >= 33',
            'Opera >= 12.16',
            'Firefox >= 28'
        ])
        .useAutopolyfiller();

    fs.readdirSync('pages').forEach(function(pageName) {
    //                ^------------------------------------------------------------ Здесь! 
        var nodeName = pageName.replace(/(.*?)\-page/, path.join('build', '$1'));

        config.node(nodeName, function (nodeConfig) {

            bevisHelper
                .sourceDeps(pageName)
                .forServerPage()
                .configureNode(nodeConfig);

            nodeConfig.addTech(require('./techs/page'));
            nodeConfig.addTarget('?.page.js');
        });

    });

};
```

Эту строку нужно заменить на: 
```
    fs.readdirSync('client/pages').forEach(function(pageName) {
    //                ^------------------------------------------------------------ Добавили client/ 
```

В этом файле мы сделали всё, что нужно. Если код файла вам не очень понятен, да и бог с ним, сейчас это не имеет 
значения. Главное — теперь сборщик будет искать страницы в папке `client/pages`.

А как сборщик понимает, откуда подтягивать ресурсы на эти страницы — все эти блоки, формочки и инпуты, все эти `i18n` и
 `y-block`? 
 
 Вот, в самом деле. Мы на прошлых занятиях активно писали файлы с зависимостями — всякие там `*.deps.yaml`,
  и говорили, что, мол, сборщик читает в этих файлах имена блоков и подтягивает их с файловой системы. Но мы не 
  обсуждали, отуда сборщик знает, _в каких именно директориях_ на файловой системе искать те блоки? Ведь, не обходит 
  же сборщик все директории проекта в поисках файлика `form.js`, если в `*.deps.yaml` описана такая 
  зависимость?
```
- block: form
```

Нет, конечно же нет. Сборщик не обходит всё дерево. Информацию о директориях с исходниками предоставляем сборщику мы - 
разработчики проекта. Мы это делаем в файле `package.json`. Вот эта 
[информация](https://github.com/bevis-ui/bevis-stub/blob/master/package.json#L33-L39):
```javascript
"enb": {
    "sources": [
        "blocks",
        "core",
        "pages"
    ]
}
```
Я привёл не весь файл, а только фрагмент (по ссылке можно увидеть всеь). Но в этом коротком фрагменте описана вся 
инструкция сборщику, где он 
должен искать исходники — только в папках  `blocks`, `core`, `pages`. 

Так как мы изменили файловую структуру проекта, следует поправить и этот фрагмент. Теперь он должен выглядеть так:
```javascript
"enb": {
    "sources": [
        "client/blocks",
        "client/core",
        "client/pages"
    ]
}
```


 



  
  
 
 



----

в разработке
